@using pax.dsstats.shared;
@using pax.dsstats.shared.Interfaces;
@inject IDamageService damageService
@implements IDisposable

<div>
    <CascadingValue Value="Request">
        <DamageRequestComponent OnRequestChanged="LoadData" OnBreakpointChanged="BreakpointChanged"></DamageRequestComponent>
    </CascadingValue>
</div>
@if (Request.FromRating != 0 || Request.ToRating != 0 || Request.Exp2WinOffset != 0)
{
    <div class="mt-2">
        <p class="text-danger">
            If you filter too much, the sample size may be too small to provide reasonable data.
        </p>
    </div>
}
<div>
    @if (isLoading)
    {
        <div class="spinner-border spinner-border-sm text-info ms-2" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    }
    else
    {
        <div class="ms-4"></div>
    }
</div>
@if (response != null)
{
    <div class="border rounded border-secondary"
         style="min-width: 800px; width: 66vw;">
        <DamageChart @ref="damageChart" Request="Request" Response="response"></DamageChart>
    </div>
}
<div class="mt-2">
    @if (response != null)
    {
        <CascadingValue Value="Request">
            <DamageTable @ref="damageTable" Response="response"></DamageTable>
        </CascadingValue>
    }
</div>

@code {
    [Parameter, EditorRequired]
    public DamageRequest Request { get; set; } = default!;

    CancellationTokenSource cts = new();
    SemaphoreSlim ss = new(1, 1);
    bool isLoading;

    DamageResponse? response = null;
    DamageTable? damageTable;
    DamageChart? damageChart;

    protected override void OnInitialized()
    {
        _ = LoadData();
        base.OnInitialized();
    }

    private async Task LoadData()
    {
        await ss.WaitAsync();
        try
        {
            isLoading = true;
            await InvokeAsync(() => StateHasChanged());
            response = await damageService.GetDamage(Request, cts.Token);

            damageChart?.SetupChart(Request, response);
            damageTable?.SetTable(response);

            isLoading = false;
            await InvokeAsync(() => StateHasChanged());
        }
        finally
        {
            ss.Release();
        }
    }

    private void BreakpointChanged()
    {
        if (response != null)
        {
            damageChart?.SetupChart(Request, response);
        }
        // damageTable?.Update();
    }

    public void Dispose()
    {
        cts.Cancel();
        cts.Dispose();
        ss.Dispose();
    }
}
