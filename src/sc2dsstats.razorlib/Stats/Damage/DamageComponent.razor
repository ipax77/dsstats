@using Microsoft.JSInterop;
@using System.Globalization;
@using pax.dsstats.shared;
@using pax.dsstats.shared.Interfaces;
@inject IDamageService damageService
@inject IJSRuntime JSRuntime
@implements IDisposable

<div>
    <CascadingValue Value="Request">
        <DamageRequestComponent OnRequestChanged="LoadData" OnBreakpointChanged="BreakpointChanged"></DamageRequestComponent>
    </CascadingValue>
</div>
@if (Request.FromRating != 0 || Request.ToRating != 0 || Request.Exp2WinOffset != 0)
{
    <div class="mt-2">
        <p class="text-danger">
            If you filter too much, the sample size may be too small to provide reasonable data.
        </p>
    </div>
}
<div>
    @if (isLoading)
    {
        <div class="spinner-border spinner-border-sm text-info ms-2" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    }
    else
    {
        <div class="ms-4"></div>
    }
</div>

@if (response != null)
{
    <div class="border rounded border-secondary bgchart"
         style="min-width: 750px; width: 70vw; height: calc(70vw * @(chartHeightCalc.ToString(CultureInfo.InvariantCulture))); min-height: @(chartMinHeight)px;">
        <DamageChart @ref="damageChart" Request="Request" Response="response" TableOrders="tableOrders"></DamageChart>
    </div>
    <div class="mt-2">
        <div class="btn-group" role="group" aria-label="Chart type toggle group">
            @{
                int i = -1;
            }
            @foreach (DamageChartType chartType in Enum.GetValues(typeof(DamageChartType)))
            {
                i++;
                <input type="radio" class="btn-check" name="@($"btndamage{i}")" id="@($"damagetype{i}")" autocomplete="off" checked="@(Request.ChartType == chartType)" @onchange="e => SetChartType(chartType)">
                <label class="btn btn-sm btn-outline-light check-label" for="@($"damagetype{i}")">@chartType</label>
            }
        </div>
    </div>
}
<div class="mt-2">
    @if (response != null)
    {
        <CascadingValue Value="Request">
            <CascadingValue Value="tableOrders">
                <DamageTable @ref="damageTable" Response="response" OnOrderChanged="OrderChanged"></DamageTable>
            </CascadingValue>
        </CascadingValue>
    }
</div>

@code {
    [Parameter, EditorRequired]
    public DamageRequest Request { get; set; } = default!;

    [Parameter]
    public EventCallback<DamageRequest> OnRequestChanged { get; set; }

    CancellationTokenSource cts = new();
    SemaphoreSlim ss = new(1, 1);
    bool isLoading;

    DamageResponse? response = null;
    DamageTable? damageTable;
    DamageChart? damageChart;

    TableOrder tableOrder = new()
    {
        Property = nameof(DamageEnt.Commander),
        Ascending = true
    };

    List<TableOrder> tableOrders = new();

    int chartMinHeight = 600;
    double chartHeightCalc = 0.75;
    WindowDimension windowDimension = new();

    protected override void OnInitialized()
    {
        tableOrders.Add(tableOrder);
        SetOrder();
        _ = LoadData();
        base.OnInitialized();
    }

    //protected override async Task OnAfterRenderAsync(bool firstRender)
    //{
    //    if (firstRender)
    //    {
    //        windowDimension = await JSRuntime.InvokeAsync<WindowDimension>("getWindowDimension");
    //    }
    //    await base.OnAfterRenderAsync(firstRender);
    //}

    private void SetChartHeight()
    {
        int commanders = Request.RatingType == RatingType.Std || Request.RatingType == RatingType.StdTE ? 3 : 17;
        chartMinHeight = commanders > 3 ? 500 : 300;
        chartHeightCalc = commanders > 3 ? 0.55 : 0.35;
    }

    private void SetOrder()
    {
        tableOrder.Property = Request.ChartType switch
        {
            DamageChartType.Damage => nameof(DamageEnt.AvgKills),
            DamageChartType.MVP => nameof(DamageEnt.MvpPercentage),
            DamageChartType.Army => nameof(DamageEnt.ArmyValue),
            _ => nameof(DamageEnt.Commander)
        };
    }

    private void SetChartType(DamageChartType chartType)
    {
        Request.ChartType = chartType;
        SetOrder();
        damageTable?.Update();
        if (response != null)
        {
            damageChart?.SetupChart(Request, response, tableOrders);
        }
        OnRequestChanged.InvokeAsync(Request);
    }

    private async Task LoadData()
    {
        await ss.WaitAsync();
        try
        {
            SetChartHeight();
            isLoading = true;
            await InvokeAsync(() => StateHasChanged());
            response = await damageService.GetDamage(Request, cts.Token);

            damageChart?.SetupChart(Request, response, tableOrders);
            damageTable?.SetTable(response);

            isLoading = false;
            await InvokeAsync(() => StateHasChanged());
            await OnRequestChanged.InvokeAsync(Request);
        }
        finally
        {
            ss.Release();
        }
    }

    private void OrderChanged()
    {
        if (response != null)
        {
            damageChart?.SetupChart(Request, response, tableOrders);
        }
    }

    private void BreakpointChanged()
    {
        if (response != null)
        {
            damageChart?.SetupChart(Request, response, tableOrders);
        }
        OnRequestChanged.InvokeAsync(Request);
        // damageTable?.Update();
    }

    public void Dispose()
    {
        cts.Cancel();
        cts.Dispose();
        ss.Dispose();
    }
}
