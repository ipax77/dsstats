{"version":3,"file":"file-handle-repository.js","mappings":"6CAEO,MAGMA,EAAS,CAClBC,QAAS,UACTC,MAAO,cACPC,KAAM,aACNC,OAAQ,SACRC,iBAAkB,oBAGtB,IAAIC,EAAyB,KAEtB,SAASC,IACZ,OAAO,IAAIC,QAAQ,CAACC,EAASC,KACzB,GAAIJ,EAEA,YADAG,EAAQH,GAIZ,MAAMK,EAAUC,UAAUC,KApBX,WACG,GAqBlBF,EAAQG,gBAAmBC,IACvB,MAAMC,EAAYD,EAAME,OAA4BC,OAC9CC,EAAMJ,EAAME,OAA4BG,YAI9C,IAAK,IAAIC,EAHUN,EAAMO,WAGAD,EA3BX,EA2B2BA,IAAK,CAC1C,MAAME,EAAYC,EAASH,GACvBE,GAAWE,QACXF,EAAUE,OAAOT,EAAUG,EAEnC,GAGJR,EAAQe,UAAY,KAChBpB,EAAKK,EAAQO,OAEbT,EAAQH,IAGZK,EAAQgB,QAAU,IAAMjB,EAAOC,EAAQiB,QAE/C,CA6BO,MAAMC,EAAwB,CACjCJ,OAAQ,CAACnB,EAAIa,KACT,MAAMW,EAAcxB,EAAGyB,iBAAiBC,SAAShC,EAAOC,SAClDkB,EAAGc,YAAYjC,EAAOC,SACtBK,EAAG4B,kBAAkBlC,EAAOC,QAAS,CAAEkC,QAAS,eAEjDL,EAAYM,WAAWJ,SAAS,aACjCF,EAAYO,YAAY,WAAY,WAAY,CAAEC,QAAQ,IAG9D,MAAMC,EAAajC,EAAGyB,iBAAiBC,SAAShC,EAAOE,OACjDiB,EAAGc,YAAYjC,EAAOE,OACtBI,EAAG4B,kBAAkBlC,EAAOE,MAAO,CAAEiC,QAAS,eAkBpD,GAhBKI,EAAWH,WAAWJ,SAAS,aAChCO,EAAWF,YAAY,WAAY,WAAY,CAAEC,QAAQ,IAExDC,EAAWH,WAAWJ,SAAS,aAChCO,EAAWF,YAAY,WAAY,WAAY,CAAEC,QAAQ,IAExDC,EAAWH,WAAWJ,SAAS,gBAChCO,EAAWF,YAAY,cAAe,cAAe,CAAEG,YAAY,IAElED,EAAWH,WAAWJ,SAAS,oBAChCO,EAAWF,YAAY,kBAAmB,kBAAmB,CAAEG,YAAY,IAE1ED,EAAWH,WAAWJ,SAAS,oBAChCO,EAAWF,YAAY,kBAAmB,kBAAmB,CAAEG,YAAY,KAG1ElC,EAAGyB,iBAAiBC,SAAShC,EAAOG,MAAO,CAC5C,MAAMsC,EAAQnC,EAAG4B,kBAAkBlC,EAAOG,KAAM,CAAEgC,QAAS,eAC3DM,EAAMJ,YAAY,WAAY,WAAY,CAAEC,QAAQ,IACpDG,EAAMJ,YAAY,WAAY,WAAY,CAAEC,QAAQ,IACpDG,EAAMJ,YAAY,OAAQ,OAAQ,CAAEC,QAAQ,GAChD,CAEKhC,EAAGyB,iBAAiBC,SAAShC,EAAOI,SACrCE,EAAG4B,kBAAkBlC,EAAOI,UA8BlCsC,EAAwB,CAC5BjB,OAAQ,CAACnB,EAAIa,KACNb,EAAGyB,iBAAiBC,SAAShC,EAAOK,mBAEvCC,EAAG4B,kBAAkBlC,EAAOK,oBAM5BmB,EAAsC,CAC1C,EAAGK,EACH,EArC4B,CAC5Bc,KAAOC,IAEL,MAAMzC,EAAOyC,EAAKC,OAAO7C,EAAOG,MAChC,GAAIA,EACF,IAAK,MAAM2C,KAAU3C,EACY,kBAApB2C,EAAOC,WAChBD,EAAOC,SAAWD,EAAOC,SAAW,EAAI,GAM9C,MAAM7C,EAAQ0C,EAAKC,OAAO7C,EAAOE,OACjC,GAAIA,EACF,IAAK,MAAM8C,KAAQ9C,EACZ8C,EAAKC,cAAaD,EAAKC,YAAc,IAK9C,OADAL,EAAKM,OAAOC,UAAY,EACjBP,IAiBT,EAAGF,E,GC3JDU,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaE,QAGrB,IAAIC,EAASN,EAAyBE,GAAY,CAGjDG,QAAS,CAAC,GAOX,OAHAE,EAAoBL,GAAUI,EAAQA,EAAOD,QAASJ,GAG/CK,EAAOD,OACf,CCrBAJ,EAAoBO,EAAI,CAACH,EAASI,KACjC,IAAI,IAAIC,KAAOD,EACXR,EAAoBU,EAAEF,EAAYC,KAAST,EAAoBU,EAAEN,EAASK,IAC5EE,OAAOC,eAAeR,EAASK,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3ET,EAAoBU,EAAI,CAACK,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,G,qFCG3EI,eAAeC,EAAoBZ,EAAaa,GACrD,MAAMrE,QAAW,UACjB,OAAO,IAAIE,QAAc,CAACC,EAASC,KACjC,MAEMkE,EAFKtE,EAAGc,YAAY,KAAOf,iBAAkB,aAClC4B,YAAY,KAAO5B,kBAClBwE,IAAIF,EAAQb,GAC9Bc,EAAIlD,UAAY,IAAMjB,IACtBmE,EAAIjD,QAAU,IAAMjB,EAAOkE,EAAIhD,QAEnC,CAEO6C,eAAeK,EAAmBhB,GACvC,MAAMxD,QAAW,UACjB,OAAO,IAAIE,QAASC,IAClB,MAEMmE,EAFKtE,EAAGc,YAAY,KAAOf,iBAAkB,YAClC4B,YAAY,KAAO5B,kBAClB8D,IAAIL,GACtBc,EAAIlD,UAAY,IAAMjB,EAAQmE,EAAI1D,QAAU,MAC5C0D,EAAIjD,QAAU,IAAMlB,EAAQ,OAEhC,CAEOgE,eAAeM,IACpB,MAAMzE,QAAW,UACjB,OAAO,IAAIE,QAASC,IAClB,MAGMuE,EAHK1E,EAAGc,YAAY,KAAOf,iBAAkB,YAClC4B,YAAY,KAAO5B,kBAEd4E,aACtBD,EAAQtD,UAAY,IAAMjB,EAAQuE,EAAQ9D,QAC1C8D,EAAQrD,QAAU,IAAMlB,EAAQ,KAEpC,CAEOgE,eAAeS,EAAsBpB,GAC1C,MAAMxD,QAAW,UACjB,OAAO,IAAIE,QAAQ,CAACC,EAASC,KAC3B,MAAMS,EAAKb,EAAGc,YAAY,KAAOf,iBAAkB,aACnDc,EAAGc,YAAY,KAAO5B,kBAAkB8E,OAAOrB,GAC/C3C,EAAGiE,WAAa,IAAM3E,GAAQ,GAC9BU,EAAGQ,QAAU,IAAMjB,EAAOS,EAAGS,QAEjC,CAEO6C,eAAeY,EAA0BV,EAA0CW,EAA6B,QACrH,IAAKX,EAAQ,OAAO,EAEpB,MAAMY,EAAO,CAAED,QAIf,GAAU,kBADOX,EAAea,kBAAkBD,IAC7B,OAAO,EAG5B,MAAa,kBADIZ,EAAec,oBAAoBF,GAEtD,CAEOd,eAAeiB,IACpB,KAAM,wBAAyBC,QAC7B,MAAM,IAAIC,MAAM,2GAGlB,IACE,aAAcD,OAAeE,qBAC/B,CAAE,MAAOjE,GACP,GAAoB,eAAhBA,GAAOkE,KACT,OAAO,KAET,MAAM,IAAIF,MAAM,6BAA6BhE,GAAOmE,SAAWnE,IACjE,CACF,C","sources":["webpack://dsstats10/./Client/db-core.ts","webpack://dsstats10/webpack/bootstrap","webpack://dsstats10/webpack/runtime/define property getters","webpack://dsstats10/webpack/runtime/hasOwnProperty shorthand","webpack://dsstats10/./Client/file-handle-repository.ts"],"sourcesContent":["import { Dump, Migration } from \"./migration.js\";\r\n\r\nexport const DB_NAME = \"ReplayDB\";\r\nexport const DB_VERSION = 3;\r\n\r\nexport const STORES = {\r\n    replays: \"Replays\",\r\n    lists: \"ReplayLists\",\r\n    meta: \"ReplayMeta\",\r\n    config: \"Config\",\r\n    directoryHandles: \"DirectoryHandles\",\r\n};\r\n\r\nlet db: IDBDatabase | null = null;\r\n\r\nexport function openDB(): Promise<IDBDatabase> {\r\n    return new Promise((resolve, reject) => {\r\n        if (db) {\r\n            resolve(db);\r\n            return;\r\n        }\r\n\r\n        const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n\r\n        request.onupgradeneeded = (event) => {\r\n            const database = (event.target as IDBOpenDBRequest).result;\r\n            const tx = (event.target as IDBOpenDBRequest).transaction!;\r\n            const oldVersion = event.oldVersion;\r\n\r\n            // Apply migrations incrementally\r\n            for (let v = oldVersion; v < DB_VERSION; v++) {\r\n                const migration = upgrades[v];\r\n                if (migration?.schema) {\r\n                    migration.schema(database, tx);\r\n                }\r\n            }\r\n        };\r\n\r\n        request.onsuccess = () => {\r\n            db = request.result;\r\n\r\n            resolve(db);\r\n        };\r\n\r\n        request.onerror = () => reject(request.error);\r\n    });\r\n}\r\n\r\nexport function closeDB(): void {\r\n    if (db) {\r\n        db.close();\r\n        db = null;\r\n    }\r\n}\r\n\r\n\r\nexport function migrateDump(dump: Dump): Dump {\r\n  let version = dump.__meta.dbVersion;\r\n\r\n  while (version < DB_VERSION) {\r\n    const migration = upgrades[version];\r\n\r\n    if (migration?.data) {\r\n      dump = migration.data(dump); // can touch any store\r\n    } else {\r\n      dump.__meta.dbVersion = version + 1;\r\n    }\r\n\r\n    version = dump.__meta.dbVersion;\r\n  }\r\n\r\n  return dump;\r\n}\r\n\r\n\r\nexport const migration0: Migration = {\r\n    schema: (db, tx) => {\r\n        const replayStore = db.objectStoreNames.contains(STORES.replays)\r\n            ? tx.objectStore(STORES.replays)\r\n            : db.createObjectStore(STORES.replays, { keyPath: \"replayHash\" });\r\n\r\n        if (!replayStore.indexNames.contains(\"gametime\")) {\r\n            replayStore.createIndex(\"gametime\", \"gametime\", { unique: false });\r\n        }\r\n\r\n        const listsStore = db.objectStoreNames.contains(STORES.lists)\r\n            ? tx.objectStore(STORES.lists)\r\n            : db.createObjectStore(STORES.lists, { keyPath: \"replayHash\" });\r\n\r\n        if (!listsStore.indexNames.contains(\"gametime\")) {\r\n            listsStore.createIndex(\"gametime\", \"gametime\", { unique: false });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"gameMode\")) {\r\n            listsStore.createIndex(\"gameMode\", \"gameMode\", { unique: false });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"playerNames\")) {\r\n            listsStore.createIndex(\"playerNames\", \"playerNames\", { multiEntry: true });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"commandersTeam1\")) {\r\n            listsStore.createIndex(\"commandersTeam1\", \"commandersTeam1\", { multiEntry: true });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"commandersTeam2\")) {\r\n            listsStore.createIndex(\"commandersTeam2\", \"commandersTeam2\", { multiEntry: true });\r\n        }\r\n\r\n        if (!db.objectStoreNames.contains(STORES.meta)) {\r\n            const store = db.createObjectStore(STORES.meta, { keyPath: \"replayHash\" });\r\n            store.createIndex(\"uploaded\", \"uploaded\", { unique: false });\r\n            store.createIndex(\"filePath\", \"filePath\", { unique: false });\r\n            store.createIndex(\"skip\", \"skip\", { unique: false });\r\n        }\r\n\r\n        if (!db.objectStoreNames.contains(STORES.config)) {\r\n            db.createObjectStore(STORES.config);\r\n        }\r\n    },\r\n};\r\n\r\nconst migration1: Migration = {\r\n  data: (dump) => {\r\n    // Adjust ReplayMeta\r\n    const meta = dump.stores[STORES.meta] as any[] | undefined;\r\n    if (meta) {\r\n      for (const record of meta) {\r\n        if (typeof record.uploaded === \"boolean\") {\r\n          record.uploaded = record.uploaded ? 1 : 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Example: adjust ReplayLists\r\n    const lists = dump.stores[STORES.lists] as any[] | undefined;\r\n    if (lists) {\r\n      for (const list of lists) {\r\n        if (!list.playerNames) list.playerNames = [];\r\n      }\r\n    }\r\n\r\n    dump.__meta.dbVersion = 2;\r\n    return dump;\r\n  },\r\n};\r\n\r\nconst migration2: Migration = {\r\n  schema: (db, tx) => {\r\n    if (!db.objectStoreNames.contains(STORES.directoryHandles)) {\r\n      // no keyPath: we'll use arbitrary string keys (e.g. 'replayDir')\r\n      db.createObjectStore(STORES.directoryHandles);\r\n    }\r\n  },\r\n};\r\n\r\n\r\nconst upgrades: Record<number, Migration> = {\r\n  0: migration0, // initial schema\r\n  1: migration1, // uploaded boolean â†’ number, can modify other stores too\r\n  2: migration2, // new store for directory handles\r\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// file-handle-repository.ts\r\nimport { openDB, STORES } from \"./db-core\";\r\n\r\nexport async function saveDirectoryHandle(key: string, handle: FileSystemDirectoryHandle): Promise<void> {\r\n  const db = await openDB();\r\n  return new Promise<void>((resolve, reject) => {\r\n    const tx = db.transaction(STORES.directoryHandles, \"readwrite\");\r\n    const store = tx.objectStore(STORES.directoryHandles);\r\n    const req = store.put(handle, key);\r\n    req.onsuccess = () => resolve();\r\n    req.onerror = () => reject(req.error);\r\n  });\r\n}\r\n\r\nexport async function getDirectoryHandle(key: string): Promise<FileSystemDirectoryHandle | null> {\r\n  const db = await openDB();\r\n  return new Promise((resolve) => {\r\n    const tx = db.transaction(STORES.directoryHandles, \"readonly\");\r\n    const store = tx.objectStore(STORES.directoryHandles);\r\n    const req = store.get(key);\r\n    req.onsuccess = () => resolve(req.result ?? null);\r\n    req.onerror = () => resolve(null);\r\n  });\r\n}\r\n\r\nexport async function getAllDirectoryHandles(): Promise<string[]> {\r\n  const db = await openDB();\r\n  return new Promise((resolve) => {\r\n    const tx = db.transaction(STORES.directoryHandles, \"readonly\");\r\n    const store = tx.objectStore(STORES.directoryHandles);\r\n\r\n    const reqKeys = store.getAllKeys();\r\n    reqKeys.onsuccess = () => resolve(reqKeys.result as string[]);\r\n    reqKeys.onerror = () => resolve([]);\r\n  });\r\n}\r\n\r\nexport async function deleteDirectoryHandle(key: string): Promise<boolean> {\r\n  const db = await openDB();\r\n  return new Promise((resolve, reject) => {\r\n    const tx = db.transaction(STORES.directoryHandles, \"readwrite\");\r\n    tx.objectStore(STORES.directoryHandles).delete(key);\r\n    tx.oncomplete = () => resolve(true);\r\n    tx.onerror = () => reject(tx.error);\r\n  });\r\n}\r\n\r\nexport async function verifyDirectoryPermission(handle: FileSystemDirectoryHandle | null, mode: 'read' | 'readwrite' = 'read'): Promise<boolean> {\r\n  if (!handle) return false;\r\n  // FileSystemHandlePermissionDescriptor\r\n  const opts = { mode };\r\n  // queryPermission exists in Chromium's implementation\r\n  // @ts-ignore - some typings may be missing\r\n  const q = await (handle as any).queryPermission?.(opts);\r\n  if (q === 'granted') return true;\r\n  // requestPermission will show a prompt if needed\r\n  const r = await (handle as any).requestPermission?.(opts);\r\n  return r === 'granted';\r\n}\r\n\r\nexport async function getDirectoryHandleFromUser(): Promise<FileSystemDirectoryHandle | null> {\r\n  if (!(\"showDirectoryPicker\" in window)) {\r\n    throw new Error(\"showDirectoryPicker is not supported in this browser. File selection requires a Chromium-based browser.\");\r\n  }\r\n\r\n  try {\r\n    return await (window as any).showDirectoryPicker();\r\n  } catch (error: any) {\r\n    if (error?.name === \"AbortError\") {\r\n      return null;\r\n    }\r\n    throw new Error(`Failed to pick directory: ${error?.message ?? error}`);\r\n  }\r\n}\r\n"],"names":["STORES","replays","lists","meta","config","directoryHandles","db","openDB","Promise","resolve","reject","request","indexedDB","open","onupgradeneeded","event","database","target","result","tx","transaction","v","oldVersion","migration","upgrades","schema","onsuccess","onerror","error","migration0","replayStore","objectStoreNames","contains","objectStore","createObjectStore","keyPath","indexNames","createIndex","unique","listsStore","multiEntry","store","migration2","data","dump","stores","record","uploaded","list","playerNames","__meta","dbVersion","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","async","saveDirectoryHandle","handle","req","put","getDirectoryHandle","getAllDirectoryHandles","reqKeys","getAllKeys","deleteDirectoryHandle","delete","oncomplete","verifyDirectoryPermission","mode","opts","queryPermission","requestPermission","getDirectoryHandleFromUser","window","Error","showDirectoryPicker","name","message"],"ignoreList":[],"sourceRoot":""}