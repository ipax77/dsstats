{"version":3,"file":"pick-replays.js","mappings":"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","sources":["webpack://dsstats10/./Client/db-core.ts","webpack://dsstats10/./Client/file-handle-repository.ts","webpack://dsstats10/webpack/bootstrap","webpack://dsstats10/webpack/runtime/define property getters","webpack://dsstats10/webpack/runtime/hasOwnProperty shorthand","webpack://dsstats10/./Client/pick-replays.ts"],"sourcesContent":["import { Dump, Migration } from \"./migration.js\";\r\n\r\nexport const DB_NAME = \"ReplayDB\";\r\nexport const DB_VERSION = 3;\r\n\r\nexport const STORES = {\r\n    replays: \"Replays\",\r\n    lists: \"ReplayLists\",\r\n    meta: \"ReplayMeta\",\r\n    config: \"Config\",\r\n    directoryHandles: \"DirectoryHandles\",\r\n};\r\n\r\nlet db: IDBDatabase | null = null;\r\n\r\nexport function openDB(): Promise<IDBDatabase> {\r\n    return new Promise((resolve, reject) => {\r\n        if (db) {\r\n            resolve(db);\r\n            return;\r\n        }\r\n\r\n        const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n\r\n        request.onupgradeneeded = (event) => {\r\n            const database = (event.target as IDBOpenDBRequest).result;\r\n            const tx = (event.target as IDBOpenDBRequest).transaction!;\r\n            const oldVersion = event.oldVersion;\r\n\r\n            // Apply migrations incrementally\r\n            for (let v = oldVersion; v < DB_VERSION; v++) {\r\n                const migration = upgrades[v];\r\n                if (migration?.schema) {\r\n                    migration.schema(database, tx);\r\n                }\r\n            }\r\n        };\r\n\r\n        request.onsuccess = () => {\r\n            db = request.result;\r\n\r\n            resolve(db);\r\n        };\r\n\r\n        request.onerror = () => reject(request.error);\r\n    });\r\n}\r\n\r\nexport function closeDB(): void {\r\n    if (db) {\r\n        db.close();\r\n        db = null;\r\n    }\r\n}\r\n\r\n\r\nexport function migrateDump(dump: Dump): Dump {\r\n  let version = dump.__meta.dbVersion;\r\n\r\n  while (version < DB_VERSION) {\r\n    const migration = upgrades[version];\r\n\r\n    if (migration?.data) {\r\n      dump = migration.data(dump); // can touch any store\r\n    } else {\r\n      dump.__meta.dbVersion = version + 1;\r\n    }\r\n\r\n    version = dump.__meta.dbVersion;\r\n  }\r\n\r\n  return dump;\r\n}\r\n\r\n\r\nexport const migration0: Migration = {\r\n    schema: (db, tx) => {\r\n        const replayStore = db.objectStoreNames.contains(STORES.replays)\r\n            ? tx.objectStore(STORES.replays)\r\n            : db.createObjectStore(STORES.replays, { keyPath: \"replayHash\" });\r\n\r\n        if (!replayStore.indexNames.contains(\"gametime\")) {\r\n            replayStore.createIndex(\"gametime\", \"gametime\", { unique: false });\r\n        }\r\n\r\n        const listsStore = db.objectStoreNames.contains(STORES.lists)\r\n            ? tx.objectStore(STORES.lists)\r\n            : db.createObjectStore(STORES.lists, { keyPath: \"replayHash\" });\r\n\r\n        if (!listsStore.indexNames.contains(\"gametime\")) {\r\n            listsStore.createIndex(\"gametime\", \"gametime\", { unique: false });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"gameMode\")) {\r\n            listsStore.createIndex(\"gameMode\", \"gameMode\", { unique: false });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"playerNames\")) {\r\n            listsStore.createIndex(\"playerNames\", \"playerNames\", { multiEntry: true });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"commandersTeam1\")) {\r\n            listsStore.createIndex(\"commandersTeam1\", \"commandersTeam1\", { multiEntry: true });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"commandersTeam2\")) {\r\n            listsStore.createIndex(\"commandersTeam2\", \"commandersTeam2\", { multiEntry: true });\r\n        }\r\n\r\n        if (!db.objectStoreNames.contains(STORES.meta)) {\r\n            const store = db.createObjectStore(STORES.meta, { keyPath: \"replayHash\" });\r\n            store.createIndex(\"uploaded\", \"uploaded\", { unique: false });\r\n            store.createIndex(\"filePath\", \"filePath\", { unique: false });\r\n            store.createIndex(\"skip\", \"skip\", { unique: false });\r\n        }\r\n\r\n        if (!db.objectStoreNames.contains(STORES.config)) {\r\n            db.createObjectStore(STORES.config);\r\n        }\r\n    },\r\n};\r\n\r\nconst migration1: Migration = {\r\n  data: (dump) => {\r\n    // Adjust ReplayMeta\r\n    const meta = dump.stores[STORES.meta] as any[] | undefined;\r\n    if (meta) {\r\n      for (const record of meta) {\r\n        if (typeof record.uploaded === \"boolean\") {\r\n          record.uploaded = record.uploaded ? 1 : 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Example: adjust ReplayLists\r\n    const lists = dump.stores[STORES.lists] as any[] | undefined;\r\n    if (lists) {\r\n      for (const list of lists) {\r\n        if (!list.playerNames) list.playerNames = [];\r\n      }\r\n    }\r\n\r\n    dump.__meta.dbVersion = 2;\r\n    return dump;\r\n  },\r\n};\r\n\r\nconst migration2: Migration = {\r\n  schema: (db, tx) => {\r\n    if (!db.objectStoreNames.contains(STORES.directoryHandles)) {\r\n      // no keyPath: we'll use arbitrary string keys (e.g. 'replayDir')\r\n      db.createObjectStore(STORES.directoryHandles);\r\n    }\r\n  },\r\n};\r\n\r\n\r\nconst upgrades: Record<number, Migration> = {\r\n  0: migration0, // initial schema\r\n  1: migration1, // uploaded boolean â†’ number, can modify other stores too\r\n  2: migration2, // new store for directory handles\r\n};","// file-handle-repository.ts\r\nimport { openDB, STORES } from \"./db-core\";\r\n\r\nexport async function saveDirectoryHandle(key: string, handle: FileSystemDirectoryHandle): Promise<void> {\r\n  const db = await openDB();\r\n  return new Promise<void>((resolve, reject) => {\r\n    const tx = db.transaction(STORES.directoryHandles, \"readwrite\");\r\n    const store = tx.objectStore(STORES.directoryHandles);\r\n    const req = store.put(handle, key);\r\n    req.onsuccess = () => resolve();\r\n    req.onerror = () => reject(req.error);\r\n  });\r\n}\r\n\r\nexport async function getDirectoryHandle(key: string): Promise<FileSystemDirectoryHandle | null> {\r\n  const db = await openDB();\r\n  return new Promise((resolve) => {\r\n    const tx = db.transaction(STORES.directoryHandles, \"readonly\");\r\n    const store = tx.objectStore(STORES.directoryHandles);\r\n    const req = store.get(key);\r\n    req.onsuccess = () => resolve(req.result ?? null);\r\n    req.onerror = () => resolve(null);\r\n  });\r\n}\r\n\r\nexport async function getAllDirectoryHandles(): Promise<string[]> {\r\n  const db = await openDB();\r\n  return new Promise((resolve) => {\r\n    const tx = db.transaction(STORES.directoryHandles, \"readonly\");\r\n    const store = tx.objectStore(STORES.directoryHandles);\r\n\r\n    const reqKeys = store.getAllKeys();\r\n    reqKeys.onsuccess = () => resolve(reqKeys.result as string[]);\r\n    reqKeys.onerror = () => resolve([]);\r\n  });\r\n}\r\n\r\nexport async function deleteDirectoryHandle(key: string): Promise<boolean> {\r\n  const db = await openDB();\r\n  return new Promise((resolve, reject) => {\r\n    const tx = db.transaction(STORES.directoryHandles, \"readwrite\");\r\n    tx.objectStore(STORES.directoryHandles).delete(key);\r\n    tx.oncomplete = () => resolve(true);\r\n    tx.onerror = () => reject(tx.error);\r\n  });\r\n}\r\n\r\nexport async function verifyDirectoryPermission(handle: FileSystemDirectoryHandle | null, mode: 'read' | 'readwrite' = 'read'): Promise<boolean> {\r\n  if (!handle) return false;\r\n  // FileSystemHandlePermissionDescriptor\r\n  const opts = { mode };\r\n  // queryPermission exists in Chromium's implementation\r\n  // @ts-ignore - some typings may be missing\r\n  const q = await (handle as any).queryPermission?.(opts);\r\n  if (q === 'granted') return true;\r\n  // requestPermission will show a prompt if needed\r\n  const r = await (handle as any).requestPermission?.(opts);\r\n  return r === 'granted';\r\n}\r\n\r\nexport async function getDirectoryHandleFromUser(): Promise<FileSystemDirectoryHandle | null> {\r\n  if (!(\"showDirectoryPicker\" in window)) {\r\n    throw new Error(\"showDirectoryPicker is not supported in this browser. File selection requires a Chromium-based browser.\");\r\n  }\r\n\r\n  try {\r\n    return await (window as any).showDirectoryPicker();\r\n  } catch (error: any) {\r\n    if (error?.name === \"AbortError\") {\r\n      return null;\r\n    }\r\n    throw new Error(`Failed to pick directory: ${error?.message ?? error}`);\r\n  }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { FileInfo, FileInfoRecord } from \"./dtos\";\r\nimport { getDirectoryHandleFromUser, saveDirectoryHandle, verifyDirectoryPermission } from \"./file-handle-repository\";\r\n\r\nconst fileHandleMap = new Map<string, File>();\r\n\r\nexport async function getReplaysFromFolder(\r\n    regionId: number,\r\n    startName: string,\r\n    existingPaths: string[],\r\n    count: number,\r\n    dirHandle?: FileSystemDirectoryHandle | null,\r\n): Promise<FileInfoRecord[]> {\r\n    fileHandleMap.clear(); // reset\r\n\r\n    const existingSet = new Set(existingPaths);\r\n    try {\r\n        if (dirHandle === null || dirHandle === undefined) {\r\n            dirHandle = await getDirectoryHandleFromUser();\r\n            if (dirHandle === null || dirHandle === undefined) {\r\n                return [];\r\n            }\r\n            await saveDirectoryHandle(`${dirHandle.name}_${regionId}`, dirHandle);\r\n        } else {\r\n            await verifyDirectoryPermission(dirHandle);\r\n        }\r\n\r\n        const records = await getFilesFromFolderRecursive(dirHandle, existingSet, startName, true, dirHandle.name);\r\n\r\n        // Filter + sort\r\n        const filtered = records\r\n            .sort((a, b) => b.record.lastModified - a.record.lastModified);\r\n\r\n        // Take only {count}\r\n        const top = filtered.slice(0, count);\r\n\r\n        // Store only those files in memory\r\n        for (const { record, file } of top) {\r\n            fileHandleMap.set(record.path, file);\r\n        }\r\n\r\n        return top.map(({ record }) => record);\r\n    } catch (error: unknown) {\r\n        console.log(\"Failed getting file infos: \" + (error as Error).message);\r\n        return [];\r\n    }\r\n}\r\n\r\nasync function getFilesFromFolderRecursive(\r\n    dirHandle: FileSystemDirectoryHandle,\r\n    existing: Set<string>,\r\n    startName: string,\r\n    recursive: boolean,\r\n    currentPath: string // initial is dirHandle.name\r\n): Promise<FileInfo[]> {\r\n    const out: FileInfo[] = [];\r\n\r\n    for await (const [name, entry] of dirHandle.entries()) {\r\n        const fullPath = currentPath ? `${currentPath}/${name}` : name;\r\n\r\n        if (entry.kind === \"directory\") {\r\n            if (recursive) {\r\n                const nested = await getFilesFromFolderRecursive(\r\n                    entry as FileSystemDirectoryHandle,\r\n                    existing,\r\n                    startName,\r\n                    recursive,\r\n                    fullPath\r\n                );\r\n                out.push(...nested);\r\n            }\r\n            continue;\r\n        }\r\n        else if (entry.kind === \"file\") {\r\n            if (!name.startsWith(startName)) continue;\r\n            if (existing.has(fullPath)) continue;\r\n\r\n            const file = await (entry as FileSystemFileHandle).getFile();\r\n            \r\n            out.push({\r\n                record: {\r\n                    path: fullPath,     // important for uniqueness in recursion\r\n                    name: file.name,\r\n                    size: file.size,\r\n                    lastModified: file.lastModified,\r\n                },\r\n                file,\r\n            });\r\n        }\r\n    }\r\n\r\n    return out;\r\n}\r\n\r\n\r\nexport async function readFileContentStream(path: string): Promise<ReadableStream<Uint8Array>> {\r\n    const file = fileHandleMap.get(path);\r\n    if (!file) throw new Error(`File not found: ${path}`);\r\n    return file.stream();\r\n}\r\n"],"names":["STORES","replays","lists","meta","config","directoryHandles","db","openDB","Promise","resolve","reject","request","indexedDB","open","onupgradeneeded","event","database","target","result","tx","transaction","v","oldVersion","migration","upgrades","schema","onsuccess","onerror","error","migration0","replayStore","objectStoreNames","contains","objectStore","createObjectStore","keyPath","indexNames","createIndex","unique","listsStore","multiEntry","store","migration2","data","dump","stores","record","uploaded","list","playerNames","__meta","dbVersion","async","saveDirectoryHandle","key","handle","req","put","verifyDirectoryPermission","mode","opts","queryPermission","requestPermission","getDirectoryHandleFromUser","window","Error","showDirectoryPicker","name","message","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","fileHandleMap","Map","getReplaysFromFolder","regionId","startName","existingPaths","count","dirHandle","clear","existingSet","Set","records","getFilesFromFolderRecursive","top","sort","a","b","lastModified","slice","file","set","path","map","console","log","existing","recursive","currentPath","out","entry","entries","fullPath","kind","startsWith","has","getFile","push","size","nested","readFileContentStream","stream"],"ignoreList":[],"sourceRoot":""}