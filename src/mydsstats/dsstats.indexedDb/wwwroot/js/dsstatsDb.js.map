{"version":3,"file":"dsstatsDb.js","mappings":"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","sources":["webpack://dsstats10/./Client/pick-replays.ts","webpack://dsstats10/./Client/stats/stats.ts","webpack://dsstats10/./Client/backup.ts","webpack://dsstats10/./Client/db-core.ts","webpack://dsstats10/./Client/file-handle-repository.ts","webpack://dsstats10/./Client/dsstatsDb.ts","webpack://dsstats10/webpack/bootstrap","webpack://dsstats10/webpack/runtime/define property getters","webpack://dsstats10/webpack/runtime/hasOwnProperty shorthand","webpack://dsstats10/webpack/startup"],"sourcesContent":["import { FileInfo, FileInfoRecord } from \"./dtos\";\r\nimport { getDirectoryHandleFromUser, saveDirectoryHandle, verifyDirectoryPermission } from \"./file-handle-repository\";\r\n\r\nconst fileHandleMap = new Map<string, File>();\r\n\r\nexport async function getReplaysFromFolder(\r\n    regionId: number,\r\n    startName: string,\r\n    existingPaths: string[],\r\n    count: number,\r\n    dirHandle?: FileSystemDirectoryHandle | null,\r\n): Promise<FileInfoRecord[]> {\r\n    fileHandleMap.clear(); // reset\r\n\r\n    const existingSet = new Set(existingPaths);\r\n    try {\r\n        if (dirHandle === null || dirHandle === undefined) {\r\n            dirHandle = await getDirectoryHandleFromUser();\r\n            if (dirHandle === null || dirHandle === undefined) {\r\n                return [];\r\n            }\r\n            await saveDirectoryHandle(`${dirHandle.name}_${regionId}`, dirHandle);\r\n        } else {\r\n            await verifyDirectoryPermission(dirHandle);\r\n        }\r\n\r\n        const records = await getFilesFromFolderRecursive(dirHandle, existingSet, startName, true, dirHandle.name);\r\n\r\n        // Filter + sort\r\n        const filtered = records\r\n            .sort((a, b) => b.record.lastModified - a.record.lastModified);\r\n\r\n        // Take only {count}\r\n        const top = filtered.slice(0, count);\r\n\r\n        // Store only those files in memory\r\n        for (const { record, file } of top) {\r\n            fileHandleMap.set(record.path, file);\r\n        }\r\n\r\n        return top.map(({ record }) => record);\r\n    } catch (error: unknown) {\r\n        console.log(\"Failed getting file infos: \" + (error as Error).message);\r\n        return [];\r\n    }\r\n}\r\n\r\nasync function getFilesFromFolderRecursive(\r\n    dirHandle: FileSystemDirectoryHandle,\r\n    existing: Set<string>,\r\n    startName: string,\r\n    recursive: boolean,\r\n    currentPath: string // initial is dirHandle.name\r\n): Promise<FileInfo[]> {\r\n    const out: FileInfo[] = [];\r\n\r\n    for await (const [name, entry] of dirHandle.entries()) {\r\n        const fullPath = currentPath ? `${currentPath}/${name}` : name;\r\n\r\n        if (entry.kind === \"directory\") {\r\n            if (recursive) {\r\n                const nested = await getFilesFromFolderRecursive(\r\n                    entry as FileSystemDirectoryHandle,\r\n                    existing,\r\n                    startName,\r\n                    recursive,\r\n                    fullPath\r\n                );\r\n                out.push(...nested);\r\n            }\r\n            continue;\r\n        }\r\n        else if (entry.kind === \"file\") {\r\n            if (!name.startsWith(startName)) continue;\r\n            if (existing.has(fullPath)) continue;\r\n\r\n            const file = await (entry as FileSystemFileHandle).getFile();\r\n            \r\n            out.push({\r\n                record: {\r\n                    path: fullPath,     // important for uniqueness in recursion\r\n                    name: file.name,\r\n                    size: file.size,\r\n                    lastModified: file.lastModified,\r\n                },\r\n                file,\r\n            });\r\n        }\r\n    }\r\n\r\n    return out;\r\n}\r\n\r\nexport async function readFileContentStream(path: string): Promise<File> {\r\n    const file = fileHandleMap.get(path);\r\n    if (!file) throw new Error(`File not found: ${path}`);\r\n    return file;\r\n}\r\n","import { getFilteredReplayLists } from '../dsstatsDb';\r\nimport { openDB, STORES } from \"../db-core\";\r\nimport { PlayerDto, ReplayDto, ReplayPlayerDto, ToonIdDto } from \"../dtos\";\r\nimport { CommanderStats, GameModeStats, MyPlayerStats, PlayerStats } from \"./stats-dto\";\r\n\r\nfunction toonKey(toon: ToonIdDto): string {\r\n    return `${toon.region}:${toon.realm}:${toon.id}`;\r\n}\r\n\r\ntype GameModeStatsBuilder = {\r\n    commanderStats: Map<number, CommanderStats>,\r\n    teammateStats: Map<string, PlayerStats>,   // keyed by toonKey\r\n    opponentStats: Map<string, PlayerStats>,   // keyed by toonKey\r\n};\r\n\r\nexport class StatsService {\r\n    \r\n    public async generateStats(player: PlayerDto): Promise<MyPlayerStats> {\r\n        const gameModeMap = new Map<number, GameModeStatsBuilder>();\r\n        const take = 100;\r\n        let afterKey: IDBValidKey | null = null;\r\n\r\n        while (true) {\r\n            const { replays, lastKey } = await this.getReplayChunk(afterKey, take);\r\n            if (replays.length === 0) {\r\n                break;\r\n            }\r\n            for (const replay of replays) {\r\n                if (!gameModeMap.has(replay.gameMode)) {\r\n                    gameModeMap.set(replay.gameMode, {\r\n                        commanderStats: new Map<number, CommanderStats>(),\r\n                        teammateStats: new Map<string, PlayerStats>(),\r\n                        opponentStats: new Map<string, PlayerStats>(),\r\n                    });\r\n                }\r\n                const gameModeStats = gameModeMap.get(replay.gameMode)!;\r\n                this.setStats(player, gameModeStats, replay);\r\n            }\r\n            afterKey = lastKey;\r\n        }\r\n\r\n        const stats: GameModeStats[] = [];\r\n        for (const [gameMode, builder] of gameModeMap.entries()) {\r\n            stats.push({\r\n                gameMode: gameMode,\r\n                commanderStats: Array.from(builder.commanderStats.values()),\r\n                teammateStats: Array.from(builder.teammateStats.values()).filter(s => s.count > 5),\r\n                opponentStats: Array.from(builder.opponentStats.values()).filter(s => s.count > 5),\r\n            });\r\n        }\r\n\r\n        const recentReplays = await getFilteredReplayLists({\r\n            name: player.name,\r\n            skip: 0,\r\n            take: 10,\r\n        });\r\n\r\n        return {\r\n            player: player,\r\n            gameModeStats: stats,\r\n            recentReplays: recentReplays,\r\n        };\r\n    }\r\n\r\n    private setStats(player: PlayerDto, gameModeStats: GameModeStatsBuilder, replay: ReplayDto) {\r\n        const myReplayPlayer = replay.players.find(\r\n            f => toonKey(f.player.toonId) === toonKey(player.toonId)\r\n        );\r\n        if (!myReplayPlayer) {\r\n            return;\r\n        }\r\n\r\n        const team = myReplayPlayer.teamId;\r\n        const win = replay.winnerTeam === team;\r\n        const commander = myReplayPlayer.race;\r\n        const isMvp = this.isMvp(myReplayPlayer, replay.players);\r\n\r\n        // Commander stats\r\n        if (gameModeStats.commanderStats.has(commander)) {\r\n            const commanderStats = gameModeStats.commanderStats.get(commander)!;\r\n            commanderStats.count += 1;\r\n            if (win) commanderStats.wins += 1;\r\n            if (isMvp) commanderStats.mvp += 1;\r\n        } else {\r\n            gameModeStats.commanderStats.set(commander, {\r\n                commander: commander,\r\n                count: 1,\r\n                wins: win ? 1 : 0,\r\n                mvp: isMvp ? 1 : 0,\r\n            });\r\n        }\r\n\r\n        // Teammate & opponent stats\r\n        for (const replayPlayer of replay.players) {\r\n            const key = toonKey(replayPlayer.player.toonId);\r\n            if (key === toonKey(player.toonId)) {\r\n                continue; // skip self\r\n            }\r\n            const isTeammate = replayPlayer.teamId === team;\r\n            const playerStatsMap = isTeammate ? gameModeStats.teammateStats : gameModeStats.opponentStats;\r\n\r\n            if (playerStatsMap.has(key)) {\r\n                const playerStats = playerStatsMap.get(key)!;\r\n                playerStats.count += 1;\r\n                if (win) {\r\n                    playerStats.wins += 1;\r\n                }\r\n            } else {\r\n                playerStatsMap.set(key, {\r\n                    player: replayPlayer.player,\r\n                    count: 1,\r\n                    wins: win ? 1 : 0,\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    private isMvp(player: ReplayPlayerDto, replayPlayers: ReplayPlayerDto[]): boolean {\r\n        let kills = 0;\r\n        for (const s of player.spawns) {\r\n            if (s.breakpoint === 4) {\r\n                kills = s.killedValue;\r\n                break;\r\n            }\r\n        }\r\n        let maxKills = 0;\r\n        for (const rp of replayPlayers) {\r\n            for (const s of rp.spawns) {\r\n                if (s.breakpoint === 4 && s.killedValue > maxKills) {\r\n                    maxKills = s.killedValue;\r\n                }\r\n            }\r\n        }\r\n        return kills > 0 && kills === maxKills;\r\n    }\r\n\r\n    public async findMainPlayer(): Promise<PlayerDto | undefined> {\r\n        const { replays: recentReplays } = await this.getReplayChunk(null, 10);\r\n        const oldestReplays = await this.getReplayChunkFromStart(10);\r\n\r\n        const allReplays = [...recentReplays, ...oldestReplays];\r\n        const playerCounts = new Map<string, { player: PlayerDto, count: number }>();\r\n\r\n        for (const replay of allReplays) {\r\n            for (const replayPlayer of replay.players) {\r\n                const key = toonKey(replayPlayer.player.toonId);\r\n                if (playerCounts.has(key)) {\r\n                    playerCounts.get(key)!.count++;\r\n                } else {\r\n                    playerCounts.set(key, { player: replayPlayer.player, count: 1 });\r\n                }\r\n            }\r\n        }\r\n\r\n        if (playerCounts.size === 0) {\r\n            return undefined;\r\n        }\r\n\r\n        let mainPlayer: { player: PlayerDto, count: number } | undefined = undefined;\r\n        for (const playerStat of playerCounts.values()) {\r\n            if (!mainPlayer || playerStat.count > mainPlayer.count) {\r\n                mainPlayer = playerStat;\r\n            }\r\n        }\r\n\r\n        return mainPlayer?.player;\r\n    }\r\n\r\n    private async getReplayChunkFromStart(take: number): Promise<ReplayDto[]> {\r\n        const db = await openDB();\r\n        return new Promise((resolve, reject) => {\r\n            const tx = db.transaction(STORES.replays, \"readonly\");\r\n            const store = tx.objectStore(STORES.replays);\r\n            const index = store.index(\"gametime\");\r\n\r\n            const replays: ReplayDto[] = [];\r\n\r\n            const request = index.openCursor(null, \"next\"); // oldest first\r\n\r\n            request.onsuccess = (event) => {\r\n                const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;\r\n                if (cursor && replays.length < take) {\r\n                    replays.push(cursor.value);\r\n                    cursor.continue();\r\n                } else {\r\n                    resolve(replays);\r\n                }\r\n            };\r\n\r\n            request.onerror = () => reject(request.error);\r\n        });\r\n    }\r\n\r\n    private async getReplayChunk(afterKey: IDBValidKey | null, take: number)\r\n     :Promise<{ replays: ReplayDto[], lastKey: IDBValidKey | null }> {\r\n        const db = await openDB();\r\n        return new Promise((resolve, reject) => {\r\n            const tx = db.transaction(STORES.replays, \"readonly\");\r\n            const store = tx.objectStore(STORES.replays);\r\n            const index = store.index(\"gametime\");\r\n\r\n            const replays: ReplayDto[] = [];\r\n            let lastKey: IDBValidKey | null = null;\r\n\r\n            // Start from \"afterKey\" if provided, otherwise from the end (descending order)\r\n            const range = afterKey ? IDBKeyRange.upperBound(afterKey, true) : null;\r\n            const request = index.openCursor(range, \"prev\"); // newest first\r\n\r\n            request.onsuccess = (event) => {\r\n                const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;\r\n                if (cursor && replays.length < take) {\r\n                    replays.push(cursor.value);\r\n                    lastKey = cursor.key;\r\n                    cursor.continue();\r\n                } else {\r\n                    resolve({ replays, lastKey });\r\n                }\r\n            };\r\n\r\n            request.onerror = () => reject(request.error);\r\n        });\r\n    }\r\n\r\n}\r\n","import { Dump } from \"./migration\";\r\nimport { openDB, migrateDump } from \"./db-core\";\r\n\r\nexport async function exportDb(): Promise<ArrayBuffer> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const tx = database.transaction(Array.from(database.objectStoreNames), \"readonly\");\r\n        const dump: Dump = { __meta: { dbVersion: database.version, date: new Date().toISOString() }, stores: {} };\r\n        let pending = database.objectStoreNames.length;\r\n\r\n        if (pending === 0) return resolve(new ArrayBuffer(0));\r\n\r\n        for (const storeName of Array.from(database.objectStoreNames)) {\r\n            const store = tx.objectStore(storeName);\r\n            const req = store.getAll();\r\n\r\n            req.onsuccess = () => {\r\n                dump.stores[storeName] = req.result;\r\n                if (--pending === 0) {\r\n                    const json = JSON.stringify(dump);\r\n                    const compressed = pako.gzip(json);\r\n                    const binary = new Uint8Array(compressed);\r\n                    resolve(binary.buffer);\r\n                }\r\n            };\r\n\r\n            req.onerror = () => reject(req.error);\r\n        }\r\n    });\r\n}\r\n\r\nexport async function importDb(json: string, replace = false): Promise<void> {\r\n    let dump: Dump = JSON.parse(json);\r\n    dump = migrateDump(dump);\r\n    const db = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const tx = db.transaction(Array.from(db.objectStoreNames), \"readwrite\");\r\n        tx.oncomplete = () => resolve();\r\n        tx.onerror = () => reject(tx.error);\r\n\r\n        for (const [storeName, items] of Object.entries(dump.stores)) {\r\n            if (!db.objectStoreNames.contains(storeName)) continue;\r\n            const store = tx.objectStore(storeName);\r\n\r\n            if (replace) {\r\n                const clearReq = store.clear();\r\n                clearReq.onsuccess = () => {\r\n                    for (const item of items) store.put(item);\r\n                };\r\n            } else {\r\n                for (const item of items) store.put(item);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Export DB and trigger a download as .json.gz.txt with timestamped filename\r\n */\r\nexport async function exportBackup(): Promise<void> {\r\n    const binary = await exportDb();\r\n\r\n    const blob = new Blob([binary], { type: \"application/gzip\" });\r\n\r\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\r\n    const filename = `dsstatsdb-backup-${timestamp}.idb.json.gz`;\r\n\r\n    const url = URL.createObjectURL(blob);\r\n    const a = document.createElement(\"a\");\r\n    a.href = url;\r\n    a.download = filename;\r\n    a.click();\r\n    URL.revokeObjectURL(url);\r\n}\r\n\r\n/**\r\n * Open file picker, read backup file and import into DB\r\n */\r\nexport async function importBackup(replace: boolean = false): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n        const input = document.createElement(\"input\");\r\n        input.type = \"file\";\r\n        input.accept = \".gz,.json\";\r\n\r\n        input.onchange = async () => {\r\n            if (!input.files || input.files.length === 0) {\r\n                return reject(\"No file selected\");\r\n            }\r\n\r\n            const file = input.files[0];\r\n            const reader = new FileReader();\r\n\r\n            reader.onload = async () => {\r\n                try {\r\n                    const buffer = reader.result as ArrayBuffer;\r\n                    const binary = new Uint8Array(buffer); // for pako\r\n                    const json = pako.ungzip(binary, { to: \"string\" });\r\n                    await importDb(json, replace);\r\n                    resolve();\r\n                } catch (err) {\r\n                    reject(err);\r\n                }\r\n            };\r\n\r\n            reader.onerror = () => reject(reader.error);\r\n            reader.readAsArrayBuffer(file);\r\n        };\r\n\r\n        input.click();\r\n    });\r\n}\r\n\r\n\r\n","import { Dump, Migration } from \"./migration.js\";\r\n\r\nexport const DB_NAME = \"ReplayDB\";\r\nexport const DB_VERSION = 3;\r\n\r\nexport const STORES = {\r\n    replays: \"Replays\",\r\n    lists: \"ReplayLists\",\r\n    meta: \"ReplayMeta\",\r\n    config: \"Config\",\r\n    directoryHandles: \"DirectoryHandles\",\r\n};\r\n\r\nlet db: IDBDatabase | null = null;\r\n\r\nexport function openDB(): Promise<IDBDatabase> {\r\n    return new Promise((resolve, reject) => {\r\n        if (db) {\r\n            resolve(db);\r\n            return;\r\n        }\r\n\r\n        const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n\r\n        request.onupgradeneeded = (event) => {\r\n            const database = (event.target as IDBOpenDBRequest).result;\r\n            const tx = (event.target as IDBOpenDBRequest).transaction!;\r\n            const oldVersion = event.oldVersion;\r\n\r\n            // Apply migrations incrementally\r\n            for (let v = oldVersion; v < DB_VERSION; v++) {\r\n                const migration = upgrades[v];\r\n                if (migration?.schema) {\r\n                    migration.schema(database, tx);\r\n                }\r\n            }\r\n        };\r\n\r\n        request.onsuccess = () => {\r\n            db = request.result;\r\n\r\n            resolve(db);\r\n        };\r\n\r\n        request.onerror = () => reject(request.error);\r\n    });\r\n}\r\n\r\nexport function closeDB(): void {\r\n    if (db) {\r\n        db.close();\r\n        db = null;\r\n    }\r\n}\r\n\r\n\r\nexport function migrateDump(dump: Dump): Dump {\r\n  let version = dump.__meta.dbVersion;\r\n\r\n  while (version < DB_VERSION) {\r\n    const migration = upgrades[version];\r\n\r\n    if (migration?.data) {\r\n      dump = migration.data(dump); // can touch any store\r\n    } else {\r\n      dump.__meta.dbVersion = version + 1;\r\n    }\r\n\r\n    version = dump.__meta.dbVersion;\r\n  }\r\n\r\n  return dump;\r\n}\r\n\r\n\r\nexport const migration0: Migration = {\r\n    schema: (db, tx) => {\r\n        const replayStore = db.objectStoreNames.contains(STORES.replays)\r\n            ? tx.objectStore(STORES.replays)\r\n            : db.createObjectStore(STORES.replays, { keyPath: \"replayHash\" });\r\n\r\n        if (!replayStore.indexNames.contains(\"gametime\")) {\r\n            replayStore.createIndex(\"gametime\", \"gametime\", { unique: false });\r\n        }\r\n\r\n        const listsStore = db.objectStoreNames.contains(STORES.lists)\r\n            ? tx.objectStore(STORES.lists)\r\n            : db.createObjectStore(STORES.lists, { keyPath: \"replayHash\" });\r\n\r\n        if (!listsStore.indexNames.contains(\"gametime\")) {\r\n            listsStore.createIndex(\"gametime\", \"gametime\", { unique: false });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"gameMode\")) {\r\n            listsStore.createIndex(\"gameMode\", \"gameMode\", { unique: false });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"playerNames\")) {\r\n            listsStore.createIndex(\"playerNames\", \"playerNames\", { multiEntry: true });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"commandersTeam1\")) {\r\n            listsStore.createIndex(\"commandersTeam1\", \"commandersTeam1\", { multiEntry: true });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"commandersTeam2\")) {\r\n            listsStore.createIndex(\"commandersTeam2\", \"commandersTeam2\", { multiEntry: true });\r\n        }\r\n\r\n        if (!db.objectStoreNames.contains(STORES.meta)) {\r\n            const store = db.createObjectStore(STORES.meta, { keyPath: \"replayHash\" });\r\n            store.createIndex(\"uploaded\", \"uploaded\", { unique: false });\r\n            store.createIndex(\"filePath\", \"filePath\", { unique: false });\r\n            store.createIndex(\"skip\", \"skip\", { unique: false });\r\n        }\r\n\r\n        if (!db.objectStoreNames.contains(STORES.config)) {\r\n            db.createObjectStore(STORES.config);\r\n        }\r\n    },\r\n};\r\n\r\nconst migration1: Migration = {\r\n  data: (dump) => {\r\n    // Adjust ReplayMeta\r\n    const meta = dump.stores[STORES.meta] as any[] | undefined;\r\n    if (meta) {\r\n      for (const record of meta) {\r\n        if (typeof record.uploaded === \"boolean\") {\r\n          record.uploaded = record.uploaded ? 1 : 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Example: adjust ReplayLists\r\n    const lists = dump.stores[STORES.lists] as any[] | undefined;\r\n    if (lists) {\r\n      for (const list of lists) {\r\n        if (!list.playerNames) list.playerNames = [];\r\n      }\r\n    }\r\n\r\n    dump.__meta.dbVersion = 2;\r\n    return dump;\r\n  },\r\n};\r\n\r\nconst migration2: Migration = {\r\n  schema: (db, tx) => {\r\n    if (!db.objectStoreNames.contains(STORES.directoryHandles)) {\r\n      // no keyPath: we'll use arbitrary string keys (e.g. 'replayDir')\r\n      db.createObjectStore(STORES.directoryHandles);\r\n    }\r\n  },\r\n};\r\n\r\n\r\nconst upgrades: Record<number, Migration> = {\r\n  0: migration0, // initial schema\r\n  1: migration1, // uploaded boolean â†’ number, can modify other stores too\r\n  2: migration2, // new store for directory handles\r\n};","// file-handle-repository.ts\r\nimport { openDB, STORES } from \"./db-core\";\r\n\r\nexport async function saveDirectoryHandle(key: string, handle: FileSystemDirectoryHandle): Promise<void> {\r\n  const db = await openDB();\r\n  return new Promise<void>((resolve, reject) => {\r\n    const tx = db.transaction(STORES.directoryHandles, \"readwrite\");\r\n    const store = tx.objectStore(STORES.directoryHandles);\r\n    const req = store.put(handle, key);\r\n    req.onsuccess = () => resolve();\r\n    req.onerror = () => reject(req.error);\r\n  });\r\n}\r\n\r\nexport async function getDirectoryHandle(key: string): Promise<FileSystemDirectoryHandle | null> {\r\n  const db = await openDB();\r\n  return new Promise((resolve) => {\r\n    const tx = db.transaction(STORES.directoryHandles, \"readonly\");\r\n    const store = tx.objectStore(STORES.directoryHandles);\r\n    const req = store.get(key);\r\n    req.onsuccess = () => resolve(req.result ?? null);\r\n    req.onerror = () => resolve(null);\r\n  });\r\n}\r\n\r\nexport async function getAllDirectoryHandles(): Promise<string[]> {\r\n  const db = await openDB();\r\n  return new Promise((resolve) => {\r\n    const tx = db.transaction(STORES.directoryHandles, \"readonly\");\r\n    const store = tx.objectStore(STORES.directoryHandles);\r\n\r\n    const reqKeys = store.getAllKeys();\r\n    reqKeys.onsuccess = () => resolve(reqKeys.result as string[]);\r\n    reqKeys.onerror = () => resolve([]);\r\n  });\r\n}\r\n\r\nexport async function deleteDirectoryHandle(key: string): Promise<boolean> {\r\n  const db = await openDB();\r\n  return new Promise((resolve, reject) => {\r\n    const tx = db.transaction(STORES.directoryHandles, \"readwrite\");\r\n    tx.objectStore(STORES.directoryHandles).delete(key);\r\n    tx.oncomplete = () => resolve(true);\r\n    tx.onerror = () => reject(tx.error);\r\n  });\r\n}\r\n\r\nexport async function verifyDirectoryPermission(handle: FileSystemDirectoryHandle | null, mode: 'read' | 'readwrite' = 'read'): Promise<boolean> {\r\n  if (!handle) return false;\r\n  // FileSystemHandlePermissionDescriptor\r\n  const opts = { mode };\r\n  // queryPermission exists in Chromium's implementation\r\n  // @ts-ignore - some typings may be missing\r\n  const q = await (handle as any).queryPermission?.(opts);\r\n  if (q === 'granted') return true;\r\n  // requestPermission will show a prompt if needed\r\n  const r = await (handle as any).requestPermission?.(opts);\r\n  return r === 'granted';\r\n}\r\n\r\nexport async function getDirectoryHandleFromUser(): Promise<FileSystemDirectoryHandle | null> {\r\n  if (!(\"showDirectoryPicker\" in window)) {\r\n    throw new Error(\"showDirectoryPicker is not supported in this browser. File selection requires a Chromium-based browser.\");\r\n  }\r\n\r\n  try {\r\n    return await (window as any).showDirectoryPicker();\r\n  } catch (error: any) {\r\n    if (error?.name === \"AbortError\") {\r\n      return null;\r\n    }\r\n    throw new Error(`Failed to pick directory: ${error?.message ?? error}`);\r\n  }\r\n}\r\n","// dsstatsDb.ts v1.4\r\nimport { openDB, STORES } from \"./db-core\";\r\nimport { ExportedReplays, FileInfoRecord, PlayerDto, PwaConfig, ReplayDto, ReplayFilter, ReplayListDto, ReplayMeta, UploadRequestDto, ExportResult } from \"./dtos\";\r\nimport { getReplaysFromFolder, readFileContentStream } from \"./pick-replays\";\r\nimport { exportBackup, importBackup } from \"./backup\";\r\nimport { MyPlayerStats } from \"./stats/stats-dto\";\r\nimport { StatsService } from \"./stats/stats\";\r\nimport { deleteDirectoryHandle, getAllDirectoryHandles, getDirectoryHandle } from \"./file-handle-repository\";\r\n\r\n// Save replay and its projection + meta in one transaction\r\nexport async function saveReplayFull(\r\n    replayHash: string,\r\n    replay: ReplayDto,\r\n    list: ReplayListDto,\r\n    meta: ReplayMeta\r\n): Promise<void> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const tx = database.transaction([STORES.replays, STORES.lists, STORES.meta], \"readwrite\");\r\n\r\n        const replays = tx.objectStore(STORES.replays);\r\n        const lists = tx.objectStore(STORES.lists);\r\n        const metas = tx.objectStore(STORES.meta);\r\n\r\n        replays.put({ ...replay, replayHash: replayHash, gametime: replay.gametime });\r\n        lists.put({ ...list, gametime: list.gametime });\r\n        metas.put(meta);\r\n\r\n        tx.oncomplete = () => resolve();\r\n        tx.onerror = () => reject(tx.error);\r\n    });\r\n}\r\n\r\n// Query for overview table\r\nexport async function getAllReplayLists(): Promise<ReplayListDto[]> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const tx = database.transaction(STORES.lists, \"readonly\");\r\n        const store = tx.objectStore(STORES.lists);\r\n\r\n        const request = store.getAll();\r\n\r\n        request.onsuccess = () => {\r\n            const results = request.result.map((r: ReplayListDto) => ({\r\n                ...r,\r\n                gameTime: r.gametime,\r\n            }));\r\n            resolve(results);\r\n        };\r\n\r\n        request.onerror = () => reject(request.error);\r\n    });\r\n}\r\n\r\nexport async function getAllReplayMatas(): Promise<ReplayMeta[]> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const tx = database.transaction(STORES.meta, \"readonly\");\r\n        const store = tx.objectStore(STORES.meta);\r\n\r\n        const request = store.getAll();\r\n\r\n        request.onsuccess = () => {\r\n            resolve(request.result);\r\n        };\r\n\r\n        request.onerror = () => reject(request.error);\r\n    });\r\n}\r\n\r\n/**\r\n * Get a full ReplayDto by replayHash\r\n */\r\nexport async function getReplayByHash(hash: string): Promise<ReplayDto | undefined> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const tx = database.transaction(STORES.replays, \"readonly\");\r\n        const store = tx.objectStore(STORES.replays);\r\n\r\n        const request = store.get(hash);\r\n\r\n        request.onsuccess = () => {\r\n            const result = request.result as ReplayDto | undefined;\r\n            if (result) {\r\n                result.gametime = new Date(result.gametime).toISOString();\r\n            }\r\n            resolve(result);\r\n        };\r\n\r\n        request.onerror = () => reject(request.error);\r\n    });\r\n}\r\n\r\n/**\r\n * Get the latest N unuploaded replays and return their hashes + gzipped data.\r\n */\r\nexport async function exportUnuploadedReplays(limit: number = 1000): Promise<ExportedReplays> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const metaTx = database.transaction(STORES.meta, \"readonly\");\r\n        const metaStore = metaTx.objectStore(STORES.meta);\r\n        const uploadedIndex = metaStore.index(\"uploaded\");\r\n\r\n        // Query all with uploaded == false\r\n        const req = uploadedIndex.getAll(IDBKeyRange.only(0));\r\n\r\n        req.onsuccess = async () => {\r\n            const metas = req.result as { replayHash: string }[];\r\n\r\n            if (metas.length === 0) {\r\n                resolve({ hashes: [], payload: gzipString(\"[]\") });\r\n                return;\r\n            }\r\n\r\n            // Fetch full replays\r\n            const replayTx = database.transaction(STORES.replays, \"readonly\");\r\n            const replayStore = replayTx.objectStore(STORES.replays);\r\n\r\n            const replayPromises = metas.map(\r\n                (m) =>\r\n                    new Promise<{ hash: string; replay?: ReplayDto }>((res, rej) => {\r\n                        const r = replayStore.get(m.replayHash);\r\n                        r.onsuccess = () => res({ hash: m.replayHash, replay: r.result as ReplayDto | undefined });\r\n                        r.onerror = () => rej(r.error);\r\n                    })\r\n            );\r\n\r\n            try {\r\n                const all = await Promise.all(replayPromises);\r\n\r\n                // Filter out undefined\r\n                const valid = all.filter((x) => !!x.replay) as { hash: string; replay: ReplayDto }[];\r\n\r\n                // Sort by gametime desc\r\n                valid.sort(\r\n                    (a, b) =>\r\n                        new Date(b.replay.gametime).getTime() -\r\n                        new Date(a.replay.gametime).getTime()\r\n                );\r\n\r\n                // Limit\r\n                const selected = valid.slice(0, limit);\r\n\r\n                // Collect\r\n                const hashes = selected.map((x) => x.hash);\r\n                const replays = selected.map((x) => x.replay);\r\n\r\n                // Compress\r\n                const payload = gzipString(JSON.stringify(replays));\r\n\r\n                resolve({ hashes, payload });\r\n            } catch (err) {\r\n                reject(err);\r\n            }\r\n        };\r\n\r\n        req.onerror = () => reject(req.error);\r\n    });\r\n}\r\n\r\n/**\r\n * Get the latest N unuploaded replays and return their hashes + gzipped data.\r\n */\r\nexport async function exportUnuploadedReplays10(uploadRequest: UploadRequestDto, limit: number = 250): Promise<ExportResult> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const metaTx = database.transaction(STORES.meta, \"readonly\");\r\n        const metaStore = metaTx.objectStore(STORES.meta);\r\n        const uploadedIndex = metaStore.index(\"uploaded\");\r\n\r\n        // Query all with uploaded == false\r\n        const req = uploadedIndex.getAll(IDBKeyRange.only(0));\r\n\r\n        req.onsuccess = async () => {\r\n            const metas = req.result as { replayHash: string }[];\r\n\r\n            if (metas.length === 0) {\r\n                resolve({ hashes: [], payload: new Uint8Array() });\r\n                return;\r\n            }\r\n\r\n            // Fetch full replays\r\n            const replayTx = database.transaction(STORES.replays, \"readonly\");\r\n            const replayStore = replayTx.objectStore(STORES.replays);\r\n\r\n            const replayPromises = metas.map(\r\n                (m) =>\r\n                    new Promise<{ hash: string; replay?: ReplayDto }>((res, rej) => {\r\n                        const r = replayStore.get(m.replayHash);\r\n                        r.onsuccess = () => res({ hash: m.replayHash, replay: r.result as ReplayDto | undefined });\r\n                        r.onerror = () => rej(r.error);\r\n                    })\r\n            );\r\n\r\n            try {\r\n                const all = await Promise.all(replayPromises);\r\n\r\n                // Filter out undefined\r\n                const valid = all.filter((x) => !!x.replay) as { hash: string; replay: ReplayDto }[];\r\n\r\n                // Sort by gametime desc\r\n                valid.sort(\r\n                    (a, b) =>\r\n                        new Date(b.replay.gametime).getTime() -\r\n                        new Date(a.replay.gametime).getTime()\r\n                );\r\n\r\n                // Limit\r\n                const selected = valid.slice(0, limit);\r\n\r\n                // Collect\r\n                const hashes = selected.map((x) => x.hash);\r\n                const replays = selected.map((x) => x.replay);\r\n\r\n                // Create a plain JS object from the .NET proxy object to avoid stack overflow issues\r\n                // when stringifying an object that contains a .NET proxy.\r\n                const plainUploadRequest = JSON.parse(JSON.stringify(uploadRequest));\r\n\r\n                const request: UploadRequestDto = {\r\n                    ...plainUploadRequest,\r\n                    replays\r\n                };\r\n\r\n                // Compress\r\n                const payload = gzipStringRaw(JSON.stringify(request));\r\n\r\n                resolve({ hashes, payload });\r\n            } catch (err) {\r\n                console.error(\"exportUnuploadedReplays10 failed:\", err);\r\n                reject(err);\r\n            }\r\n        };\r\n\r\n        req.onerror = () => reject(req.error);\r\n    });\r\n}\r\n\r\nexport async function markReplaysAsUploaded(hashes: string[]): Promise<void> {\r\n    const database = await openDB();\r\n    const tx = database.transaction(STORES.meta, \"readwrite\");\r\n    const store = tx.objectStore(STORES.meta);\r\n\r\n    await Promise.all(\r\n        hashes.map(\r\n            (hash) =>\r\n                new Promise<void>((res, rej) => {\r\n                    const getReq = store.get(hash);\r\n                    getReq.onsuccess = () => {\r\n                        const record = getReq.result;\r\n                        if (record) {\r\n                            record.uploaded = 1;\r\n                            const putReq = store.put(record);\r\n                            putReq.onsuccess = () => res();\r\n                            putReq.onerror = () => rej(putReq.error);\r\n                        } else {\r\n                            res(); // nothing to update\r\n                        }\r\n                    };\r\n                    getReq.onerror = () => rej(getReq.error);\r\n                })\r\n        )\r\n    );\r\n}\r\n\r\nexport async function pickDirectoryInit(\r\n    regionId: number,\r\n    startName: string,\r\n    dirKey?: string,\r\n    count: number = 100\r\n): Promise<FileInfoRecord[]> {\r\n    const metas = await getAllReplayMatas();\r\n    const paths = metas.filter(f => f.regionId === regionId).map(m => m.filePath);\r\n    const dirHandle = !dirKey ? null : await getDirectoryHandle(dirKey);\r\n    return await getReplaysFromFolder(regionId, startName, paths, count, dirHandle ?? undefined);\r\n}\r\n\r\nexport async function getFileContentStream(path: string) {\r\n    return await readFileContentStream(path);\r\n}\r\n\r\nexport async function getConfig(): Promise<PwaConfig | undefined> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const tx = database.transaction(STORES.config, \"readonly\");\r\n        const store = tx.objectStore(STORES.config);\r\n\r\n        const request = store.get(\"app\");\r\n\r\n        request.onsuccess = () => {\r\n            resolve(request.result);\r\n        };\r\n\r\n        request.onerror = () => reject(request.error);\r\n    });\r\n}\r\n\r\nexport async function saveConfig(\r\n    config: PwaConfig,\r\n): Promise<void> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const tx = database.transaction(STORES.config, \"readwrite\");\r\n\r\n        const configs = tx.objectStore(STORES.config);\r\n        configs.put(config, \"app\");\r\n\r\n        tx.oncomplete = () => resolve();\r\n        tx.onerror = () => reject(tx.error);\r\n    });\r\n}\r\n\r\n\r\n\r\nasync function _getFilteredReplayLists(filter: ReplayFilter): Promise<ReplayListDto[]> {\r\n    const database = await openDB();\r\n\r\n    const hasNameFilter = filter.name && filter.name.length > 0;\r\n    const hasCommandersFilter = filter.commanders && filter.commanders.length > 0;\r\n\r\n    const tx = database.transaction(STORES.lists, \"readonly\");\r\n    const store = tx.objectStore(STORES.lists);\r\n\r\n    let initialReplayLists: ReplayListDto[] = [];\r\n\r\n    if (hasCommandersFilter) {\r\n        const team1Index = store.index(\"commandersTeam1\");\r\n        const team2Index = store.index(\"commandersTeam2\");\r\n        const addedHashes = new Set<string>();\r\n\r\n        const promises = filter.commanders!.map(commander => {\r\n            return [\r\n                new Promise<ReplayListDto[]>((res, rej) => {\r\n                    const req = team1Index.getAll(IDBKeyRange.only(commander));\r\n                    req.onsuccess = () => res(req.result);\r\n                    req.onerror = () => rej(req.error);\r\n                }),\r\n                new Promise<ReplayListDto[]>((res, rej) => {\r\n                    const req = team2Index.getAll(IDBKeyRange.only(commander));\r\n                    req.onsuccess = () => res(req.result);\r\n                    req.onerror = () => rej(req.error);\r\n                })\r\n            ];\r\n        }).flat();\r\n\r\n        const results = await Promise.all(promises);\r\n        results.flat().forEach(replay => {\r\n            if (!addedHashes.has(replay.replayHash)) {\r\n                initialReplayLists.push(replay);\r\n                addedHashes.add(replay.replayHash);\r\n            }\r\n        });\r\n    } else {\r\n        initialReplayLists = await new Promise<ReplayListDto[]>((res, rej) => {\r\n            const req = store.getAll();\r\n            req.onsuccess = () => res(req.result);\r\n            req.onerror = () => rej(req.error);\r\n        });\r\n    }\r\n\r\n    if (!hasNameFilter) {\r\n        return initialReplayLists;\r\n    }\r\n\r\n    const searchNames = hasNameFilter ? filter.name!.toLowerCase().split(' ').filter(n => n) : [];\r\n\r\n    return initialReplayLists.filter(replayList => {\r\n        if (filter.linkCommanders && hasNameFilter && hasCommandersFilter) {\r\n            const lowerCasePlayerNames = replayList.playerNames.map(name => name.toLowerCase());\r\n            const allCommanders = [...replayList.commandersTeam1, ...replayList.commandersTeam2];\r\n\r\n            return lowerCasePlayerNames.some((playerName, playerIndex) => {\r\n                const nameMatch = searchNames.every(searchName => playerName.includes(searchName));\r\n                if (nameMatch) {\r\n                    const commander = allCommanders[playerIndex];\r\n                    return filter.commanders!.includes(commander);\r\n                }\r\n                return false;\r\n            });\r\n        }\r\n\r\n        if (hasNameFilter) {\r\n            const lowerCasePlayerNames = replayList.playerNames.map(name => name.toLowerCase());\r\n            return searchNames.every(searchName => lowerCasePlayerNames.some(playerName => playerName.includes(searchName)));\r\n        }\r\n\r\n        return true;\r\n    });\r\n}\r\n\r\nexport async function getFilteredReplayLists(\r\n    filter: ReplayFilter\r\n): Promise<ReplayListDto[]> {\r\n    const filteredResults = await _getFilteredReplayLists(filter);\r\n\r\n    const orders = (filter.tableOrders && filter.tableOrders.length > 0)\r\n        ? filter.tableOrders\r\n        : [{ name: 'gametime', ascending: false }];\r\n\r\n    filteredResults.sort((a, b) => {\r\n        for (const order of orders) {\r\n            const aValue = a[order.name as keyof ReplayListDto];\r\n            const bValue = b[order.name as keyof ReplayListDto];\r\n\r\n            // Assuming array properties are not used for sorting\r\n            if (Array.isArray(aValue) || Array.isArray(bValue)) {\r\n                continue;\r\n            }\r\n\r\n            const valA = aValue === undefined ? 0 : aValue;\r\n            const valB = bValue === undefined ? 0 : bValue;\r\n\r\n            if (valA < valB) {\r\n                return order.ascending ? -1 : 1;\r\n            }\r\n            if (valA > valB) {\r\n                return order.ascending ? 1 : -1;\r\n            }\r\n        }\r\n        return 0;\r\n    });\r\n\r\n    if (filter.skip !== undefined && filter.take !== undefined) {\r\n        return filteredResults.slice(filter.skip, filter.skip + filter.take);\r\n    }\r\n    return filteredResults;\r\n}\r\n\r\nexport async function getFilteredReplayListsCount(filter: ReplayFilter): Promise<number> {\r\n    const filteredResults = await _getFilteredReplayLists(filter);\r\n    return filteredResults.length;\r\n}\r\n\r\nexport async function downloadBackup() {\r\n    await exportBackup();\r\n}\r\n\r\nexport async function uploadBackup() {\r\n    await importBackup();\r\n}\r\n\r\nexport function gzipString(content: string): string {\r\n    const binary = pako.gzip(content);\r\n    return btoa(String.fromCharCode(...binary));\r\n}\r\n\r\nexport function gzipStringRaw(content: string): Uint8Array {\r\n    return pako.gzip(content);\r\n}\r\n\r\nexport function ungzipString(base64: string): string {\r\n    const binary = Uint8Array.from(atob(base64), c => c.charCodeAt(0));\r\n    const text = pako.ungzip(binary, { to: \"string\" });\r\n    return text;\r\n}\r\n\r\nexport async function getPlayerStats(player: PlayerDto): Promise<MyPlayerStats> {\r\n    const statsService = new StatsService();\r\n    return await statsService.generateStats(player);\r\n}\r\n\r\nexport async function exportAllDirectoryHandles(): Promise<string[]> {\r\n    return await getAllDirectoryHandles();\r\n}\r\n\r\nexport async function delDirectoryHandle(key: string): Promise<void> {\r\n    await deleteDirectoryHandle(key);\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(691);\n"],"names":["fileHandleMap","Map","async","getReplaysFromFolder","regionId","startName","existingPaths","count","dirHandle","clear","existingSet","Set","name","records","getFilesFromFolderRecursive","top","sort","a","b","record","lastModified","slice","file","set","path","map","error","console","log","message","existing","recursive","currentPath","out","entry","entries","fullPath","kind","startsWith","has","getFile","push","size","nested","readFileContentStream","get","Error","toonKey","toon","region","realm","id","StatsService","generateStats","player","gameModeMap","afterKey","replays","lastKey","this","getReplayChunk","length","replay","gameMode","commanderStats","teammateStats","opponentStats","gameModeStats","setStats","stats","builder","Array","from","values","filter","s","recentReplays","skip","take","myReplayPlayer","players","find","f","toonId","team","teamId","win","winnerTeam","commander","race","isMvp","wins","mvp","replayPlayer","key","playerStatsMap","playerStats","replayPlayers","kills","spawns","breakpoint","killedValue","maxKills","rp","findMainPlayer","allReplays","getReplayChunkFromStart","playerCounts","mainPlayer","playerStat","db","Promise","resolve","reject","index","transaction","objectStore","request","openCursor","onsuccess","event","cursor","target","result","value","continue","onerror","range","IDBKeyRange","upperBound","exportBackup","binary","database","tx","objectStoreNames","dump","__meta","dbVersion","version","date","Date","toISOString","stores","pending","ArrayBuffer","storeName","req","getAll","json","JSON","stringify","compressed","pako","gzip","Uint8Array","buffer","exportDb","blob","Blob","type","filename","replace","url","URL","createObjectURL","document","createElement","href","download","click","revokeObjectURL","importBackup","input","accept","onchange","files","reader","FileReader","onload","ungzip","to","parse","oncomplete","items","Object","contains","store","item","put","importDb","err","readAsArrayBuffer","STORES","lists","meta","config","directoryHandles","openDB","indexedDB","open","onupgradeneeded","v","oldVersion","migration","upgrades","schema","migrateDump","data","migration0","replayStore","createObjectStore","keyPath","indexNames","createIndex","unique","listsStore","multiEntry","migration2","uploaded","list","playerNames","saveDirectoryHandle","handle","getDirectoryHandle","getAllDirectoryHandles","reqKeys","getAllKeys","deleteDirectoryHandle","delete","verifyDirectoryPermission","mode","opts","queryPermission","requestPermission","getDirectoryHandleFromUser","window","showDirectoryPicker","saveReplayFull","replayHash","metas","gametime","getAllReplayLists","results","r","gameTime","getAllReplayMatas","getReplayByHash","hash","exportUnuploadedReplays","limit","only","hashes","payload","gzipString","replayPromises","m","res","rej","valid","all","x","getTime","selected","exportUnuploadedReplays10","uploadRequest","gzipStringRaw","markReplaysAsUploaded","getReq","putReq","pickDirectoryInit","dirKey","paths","filePath","undefined","getFileContentStream","getConfig","saveConfig","_getFilteredReplayLists","hasNameFilter","hasCommandersFilter","commanders","initialReplayLists","team1Index","team2Index","addedHashes","promises","flat","forEach","add","searchNames","toLowerCase","split","n","replayList","linkCommanders","lowerCasePlayerNames","allCommanders","commandersTeam1","commandersTeam2","some","playerName","playerIndex","every","searchName","includes","getFilteredReplayLists","filteredResults","orders","tableOrders","ascending","order","aValue","bValue","isArray","valA","valB","getFilteredReplayListsCount","downloadBackup","uploadBackup","content","btoa","String","fromCharCode","ungzipString","base64","atob","c","charCodeAt","getPlayerStats","statsService","exportAllDirectoryHandles","delDirectoryHandle","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","d","definition","o","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","__webpack_exports__"],"ignoreList":[],"sourceRoot":""}