{"version":3,"file":"db-core.js","mappings":"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","sources":["webpack://dsstats10/webpack/bootstrap","webpack://dsstats10/webpack/runtime/define property getters","webpack://dsstats10/webpack/runtime/hasOwnProperty shorthand","webpack://dsstats10/./Client/db-core.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { Dump, Migration } from \"./migration.js\";\r\n\r\nexport const DB_NAME = \"ReplayDB\";\r\nexport const DB_VERSION = 3;\r\n\r\nexport const STORES = {\r\n    replays: \"Replays\",\r\n    lists: \"ReplayLists\",\r\n    meta: \"ReplayMeta\",\r\n    config: \"Config\",\r\n    directoryHandles: \"DirectoryHandles\",\r\n};\r\n\r\nlet db: IDBDatabase | null = null;\r\n\r\nexport function openDB(): Promise<IDBDatabase> {\r\n    return new Promise((resolve, reject) => {\r\n        if (db) {\r\n            resolve(db);\r\n            return;\r\n        }\r\n\r\n        const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n\r\n        request.onupgradeneeded = (event) => {\r\n            const database = (event.target as IDBOpenDBRequest).result;\r\n            const tx = (event.target as IDBOpenDBRequest).transaction!;\r\n            const oldVersion = event.oldVersion;\r\n\r\n            // Apply migrations incrementally\r\n            for (let v = oldVersion; v < DB_VERSION; v++) {\r\n                const migration = upgrades[v];\r\n                if (migration?.schema) {\r\n                    migration.schema(database, tx);\r\n                }\r\n            }\r\n        };\r\n\r\n        request.onsuccess = () => {\r\n            db = request.result;\r\n\r\n            resolve(db);\r\n        };\r\n\r\n        request.onerror = () => reject(request.error);\r\n    });\r\n}\r\n\r\nexport function closeDB(): void {\r\n    if (db) {\r\n        db.close();\r\n        db = null;\r\n    }\r\n}\r\n\r\n\r\nexport function migrateDump(dump: Dump): Dump {\r\n  let version = dump.__meta.dbVersion;\r\n\r\n  while (version < DB_VERSION) {\r\n    const migration = upgrades[version];\r\n\r\n    if (migration?.data) {\r\n      dump = migration.data(dump); // can touch any store\r\n    } else {\r\n      dump.__meta.dbVersion = version + 1;\r\n    }\r\n\r\n    version = dump.__meta.dbVersion;\r\n  }\r\n\r\n  return dump;\r\n}\r\n\r\n\r\nexport const migration0: Migration = {\r\n    schema: (db, tx) => {\r\n        const replayStore = db.objectStoreNames.contains(STORES.replays)\r\n            ? tx.objectStore(STORES.replays)\r\n            : db.createObjectStore(STORES.replays, { keyPath: \"replayHash\" });\r\n\r\n        if (!replayStore.indexNames.contains(\"gametime\")) {\r\n            replayStore.createIndex(\"gametime\", \"gametime\", { unique: false });\r\n        }\r\n\r\n        const listsStore = db.objectStoreNames.contains(STORES.lists)\r\n            ? tx.objectStore(STORES.lists)\r\n            : db.createObjectStore(STORES.lists, { keyPath: \"replayHash\" });\r\n\r\n        if (!listsStore.indexNames.contains(\"gametime\")) {\r\n            listsStore.createIndex(\"gametime\", \"gametime\", { unique: false });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"gameMode\")) {\r\n            listsStore.createIndex(\"gameMode\", \"gameMode\", { unique: false });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"playerNames\")) {\r\n            listsStore.createIndex(\"playerNames\", \"playerNames\", { multiEntry: true });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"commandersTeam1\")) {\r\n            listsStore.createIndex(\"commandersTeam1\", \"commandersTeam1\", { multiEntry: true });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"commandersTeam2\")) {\r\n            listsStore.createIndex(\"commandersTeam2\", \"commandersTeam2\", { multiEntry: true });\r\n        }\r\n\r\n        if (!db.objectStoreNames.contains(STORES.meta)) {\r\n            const store = db.createObjectStore(STORES.meta, { keyPath: \"replayHash\" });\r\n            store.createIndex(\"uploaded\", \"uploaded\", { unique: false });\r\n            store.createIndex(\"filePath\", \"filePath\", { unique: false });\r\n            store.createIndex(\"skip\", \"skip\", { unique: false });\r\n        }\r\n\r\n        if (!db.objectStoreNames.contains(STORES.config)) {\r\n            db.createObjectStore(STORES.config);\r\n        }\r\n    },\r\n};\r\n\r\nconst migration1: Migration = {\r\n  data: (dump) => {\r\n    // Adjust ReplayMeta\r\n    const meta = dump.stores[STORES.meta] as any[] | undefined;\r\n    if (meta) {\r\n      for (const record of meta) {\r\n        if (typeof record.uploaded === \"boolean\") {\r\n          record.uploaded = record.uploaded ? 1 : 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Example: adjust ReplayLists\r\n    const lists = dump.stores[STORES.lists] as any[] | undefined;\r\n    if (lists) {\r\n      for (const list of lists) {\r\n        if (!list.playerNames) list.playerNames = [];\r\n      }\r\n    }\r\n\r\n    dump.__meta.dbVersion = 2;\r\n    return dump;\r\n  },\r\n};\r\n\r\nconst migration2: Migration = {\r\n  schema: (db, tx) => {\r\n    if (!db.objectStoreNames.contains(STORES.directoryHandles)) {\r\n      // no keyPath: we'll use arbitrary string keys (e.g. 'replayDir')\r\n      db.createObjectStore(STORES.directoryHandles);\r\n    }\r\n  },\r\n};\r\n\r\n\r\nconst upgrades: Record<number, Migration> = {\r\n  0: migration0, // initial schema\r\n  1: migration1, // uploaded boolean â†’ number, can modify other stores too\r\n  2: migration2, // new store for directory handles\r\n};"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","DB_NAME","DB_VERSION","STORES","replays","lists","meta","config","directoryHandles","db","openDB","Promise","resolve","reject","request","indexedDB","open","onupgradeneeded","event","database","target","result","tx","transaction","v","oldVersion","migration","upgrades","schema","onsuccess","onerror","error","closeDB","close","migrateDump","dump","version","__meta","dbVersion","data","migration0","replayStore","objectStoreNames","contains","objectStore","createObjectStore","keyPath","indexNames","createIndex","unique","listsStore","multiEntry","store","migration2","stores","record","uploaded","list","playerNames"],"ignoreList":[],"sourceRoot":""}