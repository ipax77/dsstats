{"version":3,"file":"stats.js","mappings":"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","sources":["webpack://dsstats10/./Client/pick-replays.ts","webpack://dsstats10/./Client/stats/stats.ts","webpack://dsstats10/./Client/db-core.ts","webpack://dsstats10/./Client/dsstatsDb.ts","webpack://dsstats10/webpack/bootstrap","webpack://dsstats10/webpack/runtime/define property getters","webpack://dsstats10/webpack/runtime/hasOwnProperty shorthand","webpack://dsstats10/webpack/startup"],"sourcesContent":["import { FileInfo, FileInfoRecord } from \"./dtos\";\r\nimport { getDirectoryHandleFromUser, saveDirectoryHandle, verifyDirectoryPermission } from \"./file-handle-repository\";\r\n\r\nconst fileHandleMap = new Map<string, File>();\r\n\r\nexport async function getReplaysFromFolder(\r\n    regionId: number,\r\n    startName: string,\r\n    existingPaths: string[],\r\n    count: number,\r\n    dirHandle?: FileSystemDirectoryHandle | null,\r\n): Promise<FileInfoRecord[]> {\r\n    fileHandleMap.clear(); // reset\r\n\r\n    const existingSet = new Set(existingPaths);\r\n    try {\r\n        if (dirHandle === null || dirHandle === undefined) {\r\n            dirHandle = await getDirectoryHandleFromUser();\r\n            if (dirHandle === null || dirHandle === undefined) {\r\n                return [];\r\n            }\r\n            await saveDirectoryHandle(`${dirHandle.name}_${regionId}`, dirHandle);\r\n        } else {\r\n            await verifyDirectoryPermission(dirHandle);\r\n        }\r\n\r\n        const records = await getFilesFromFolderRecursive(dirHandle, existingSet, startName, true, dirHandle.name);\r\n\r\n        // Filter + sort\r\n        const filtered = records\r\n            .sort((a, b) => b.record.lastModified - a.record.lastModified);\r\n\r\n        // Take only {count}\r\n        const top = filtered.slice(0, count);\r\n\r\n        // Store only those files in memory\r\n        for (const { record, file } of top) {\r\n            fileHandleMap.set(record.path, file);\r\n        }\r\n\r\n        return top.map(({ record }) => record);\r\n    } catch (error: unknown) {\r\n        console.log(\"Failed getting file infos: \" + (error as Error).message);\r\n        return [];\r\n    }\r\n}\r\n\r\nasync function getFilesFromFolderRecursive(\r\n    dirHandle: FileSystemDirectoryHandle,\r\n    existing: Set<string>,\r\n    startName: string,\r\n    recursive: boolean,\r\n    currentPath: string // initial is dirHandle.name\r\n): Promise<FileInfo[]> {\r\n    const out: FileInfo[] = [];\r\n\r\n    for await (const [name, entry] of dirHandle.entries()) {\r\n        const fullPath = currentPath ? `${currentPath}/${name}` : name;\r\n\r\n        if (entry.kind === \"directory\") {\r\n            if (recursive) {\r\n                const nested = await getFilesFromFolderRecursive(\r\n                    entry as FileSystemDirectoryHandle,\r\n                    existing,\r\n                    startName,\r\n                    recursive,\r\n                    fullPath\r\n                );\r\n                out.push(...nested);\r\n            }\r\n            continue;\r\n        }\r\n        else if (entry.kind === \"file\") {\r\n            if (!name.startsWith(startName)) continue;\r\n            if (existing.has(fullPath)) continue;\r\n\r\n            const file = await (entry as FileSystemFileHandle).getFile();\r\n            \r\n            out.push({\r\n                record: {\r\n                    path: fullPath,     // important for uniqueness in recursion\r\n                    name: file.name,\r\n                    size: file.size,\r\n                    lastModified: file.lastModified,\r\n                },\r\n                file,\r\n            });\r\n        }\r\n    }\r\n\r\n    return out;\r\n}\r\n\r\nexport async function readFileContentStream(path: string): Promise<File> {\r\n    const file = fileHandleMap.get(path);\r\n    if (!file) throw new Error(`File not found: ${path}`);\r\n    return file;\r\n}\r\n","import { getFilteredReplayLists } from '../dsstatsDb';\r\nimport { openDB, STORES } from \"../db-core\";\r\nimport { PlayerDto, ReplayDto, ReplayPlayerDto, ToonIdDto } from \"../dtos\";\r\nimport { CommanderStats, GameModeStats, MyPlayerStats, PlayerStats } from \"./stats-dto\";\r\n\r\nfunction toonKey(toon: ToonIdDto): string {\r\n    return `${toon.region}:${toon.realm}:${toon.id}`;\r\n}\r\n\r\ntype GameModeStatsBuilder = {\r\n    commanderStats: Map<number, CommanderStats>,\r\n    teammateStats: Map<string, PlayerStats>,   // keyed by toonKey\r\n    opponentStats: Map<string, PlayerStats>,   // keyed by toonKey\r\n};\r\n\r\nexport class StatsService {\r\n    \r\n    public async generateStats(player: PlayerDto): Promise<MyPlayerStats> {\r\n        const gameModeMap = new Map<number, GameModeStatsBuilder>();\r\n        const take = 100;\r\n        let afterKey: IDBValidKey | null = null;\r\n\r\n        while (true) {\r\n            const { replays, lastKey } = await this.getReplayChunk(afterKey, take);\r\n            if (replays.length === 0) {\r\n                break;\r\n            }\r\n            for (const replay of replays) {\r\n                if (!gameModeMap.has(replay.gameMode)) {\r\n                    gameModeMap.set(replay.gameMode, {\r\n                        commanderStats: new Map<number, CommanderStats>(),\r\n                        teammateStats: new Map<string, PlayerStats>(),\r\n                        opponentStats: new Map<string, PlayerStats>(),\r\n                    });\r\n                }\r\n                const gameModeStats = gameModeMap.get(replay.gameMode)!;\r\n                this.setStats(player, gameModeStats, replay);\r\n            }\r\n            afterKey = lastKey;\r\n        }\r\n\r\n        const stats: GameModeStats[] = [];\r\n        for (const [gameMode, builder] of gameModeMap.entries()) {\r\n            stats.push({\r\n                gameMode: gameMode,\r\n                commanderStats: Array.from(builder.commanderStats.values()),\r\n                teammateStats: Array.from(builder.teammateStats.values()).filter(s => s.count > 5),\r\n                opponentStats: Array.from(builder.opponentStats.values()).filter(s => s.count > 5),\r\n            });\r\n        }\r\n\r\n        const recentReplays = await getFilteredReplayLists({\r\n            name: player.name,\r\n            skip: 0,\r\n            take: 10,\r\n        });\r\n\r\n        return {\r\n            player: player,\r\n            gameModeStats: stats,\r\n            recentReplays: recentReplays,\r\n        };\r\n    }\r\n\r\n    private setStats(player: PlayerDto, gameModeStats: GameModeStatsBuilder, replay: ReplayDto) {\r\n        const myReplayPlayer = replay.players.find(\r\n            f => toonKey(f.player.toonId) === toonKey(player.toonId)\r\n        );\r\n        if (!myReplayPlayer) {\r\n            return;\r\n        }\r\n\r\n        const team = myReplayPlayer.teamId;\r\n        const win = replay.winnerTeam === team;\r\n        const commander = myReplayPlayer.race;\r\n        const isMvp = this.isMvp(myReplayPlayer, replay.players);\r\n\r\n        // Commander stats\r\n        if (gameModeStats.commanderStats.has(commander)) {\r\n            const commanderStats = gameModeStats.commanderStats.get(commander)!;\r\n            commanderStats.count += 1;\r\n            if (win) commanderStats.wins += 1;\r\n            if (isMvp) commanderStats.mvp += 1;\r\n        } else {\r\n            gameModeStats.commanderStats.set(commander, {\r\n                commander: commander,\r\n                count: 1,\r\n                wins: win ? 1 : 0,\r\n                mvp: isMvp ? 1 : 0,\r\n            });\r\n        }\r\n\r\n        // Teammate & opponent stats\r\n        for (const replayPlayer of replay.players) {\r\n            const key = toonKey(replayPlayer.player.toonId);\r\n            if (key === toonKey(player.toonId)) {\r\n                continue; // skip self\r\n            }\r\n            const isTeammate = replayPlayer.teamId === team;\r\n            const playerStatsMap = isTeammate ? gameModeStats.teammateStats : gameModeStats.opponentStats;\r\n\r\n            if (playerStatsMap.has(key)) {\r\n                const playerStats = playerStatsMap.get(key)!;\r\n                playerStats.count += 1;\r\n                if (win) {\r\n                    playerStats.wins += 1;\r\n                }\r\n            } else {\r\n                playerStatsMap.set(key, {\r\n                    player: replayPlayer.player,\r\n                    count: 1,\r\n                    wins: win ? 1 : 0,\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    private isMvp(player: ReplayPlayerDto, replayPlayers: ReplayPlayerDto[]): boolean {\r\n        let kills = 0;\r\n        for (const s of player.spawns) {\r\n            if (s.breakpoint === 4) {\r\n                kills = s.killedValue;\r\n                break;\r\n            }\r\n        }\r\n        let maxKills = 0;\r\n        for (const rp of replayPlayers) {\r\n            for (const s of rp.spawns) {\r\n                if (s.breakpoint === 4 && s.killedValue > maxKills) {\r\n                    maxKills = s.killedValue;\r\n                }\r\n            }\r\n        }\r\n        return kills > 0 && kills === maxKills;\r\n    }\r\n\r\n    public async findMainPlayer(): Promise<PlayerDto | undefined> {\r\n        const { replays: recentReplays } = await this.getReplayChunk(null, 10);\r\n        const oldestReplays = await this.getReplayChunkFromStart(10);\r\n\r\n        const allReplays = [...recentReplays, ...oldestReplays];\r\n        const playerCounts = new Map<string, { player: PlayerDto, count: number }>();\r\n\r\n        for (const replay of allReplays) {\r\n            for (const replayPlayer of replay.players) {\r\n                const key = toonKey(replayPlayer.player.toonId);\r\n                if (playerCounts.has(key)) {\r\n                    playerCounts.get(key)!.count++;\r\n                } else {\r\n                    playerCounts.set(key, { player: replayPlayer.player, count: 1 });\r\n                }\r\n            }\r\n        }\r\n\r\n        if (playerCounts.size === 0) {\r\n            return undefined;\r\n        }\r\n\r\n        let mainPlayer: { player: PlayerDto, count: number } | undefined = undefined;\r\n        for (const playerStat of playerCounts.values()) {\r\n            if (!mainPlayer || playerStat.count > mainPlayer.count) {\r\n                mainPlayer = playerStat;\r\n            }\r\n        }\r\n\r\n        return mainPlayer?.player;\r\n    }\r\n\r\n    private async getReplayChunkFromStart(take: number): Promise<ReplayDto[]> {\r\n        const db = await openDB();\r\n        return new Promise((resolve, reject) => {\r\n            const tx = db.transaction(STORES.replays, \"readonly\");\r\n            const store = tx.objectStore(STORES.replays);\r\n            const index = store.index(\"gametime\");\r\n\r\n            const replays: ReplayDto[] = [];\r\n\r\n            const request = index.openCursor(null, \"next\"); // oldest first\r\n\r\n            request.onsuccess = (event) => {\r\n                const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;\r\n                if (cursor && replays.length < take) {\r\n                    replays.push(cursor.value);\r\n                    cursor.continue();\r\n                } else {\r\n                    resolve(replays);\r\n                }\r\n            };\r\n\r\n            request.onerror = () => reject(request.error);\r\n        });\r\n    }\r\n\r\n    private async getReplayChunk(afterKey: IDBValidKey | null, take: number)\r\n     :Promise<{ replays: ReplayDto[], lastKey: IDBValidKey | null }> {\r\n        const db = await openDB();\r\n        return new Promise((resolve, reject) => {\r\n            const tx = db.transaction(STORES.replays, \"readonly\");\r\n            const store = tx.objectStore(STORES.replays);\r\n            const index = store.index(\"gametime\");\r\n\r\n            const replays: ReplayDto[] = [];\r\n            let lastKey: IDBValidKey | null = null;\r\n\r\n            // Start from \"afterKey\" if provided, otherwise from the end (descending order)\r\n            const range = afterKey ? IDBKeyRange.upperBound(afterKey, true) : null;\r\n            const request = index.openCursor(range, \"prev\"); // newest first\r\n\r\n            request.onsuccess = (event) => {\r\n                const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;\r\n                if (cursor && replays.length < take) {\r\n                    replays.push(cursor.value);\r\n                    lastKey = cursor.key;\r\n                    cursor.continue();\r\n                } else {\r\n                    resolve({ replays, lastKey });\r\n                }\r\n            };\r\n\r\n            request.onerror = () => reject(request.error);\r\n        });\r\n    }\r\n\r\n}\r\n","import { Dump, Migration } from \"./migration.js\";\r\n\r\nexport const DB_NAME = \"ReplayDB\";\r\nexport const DB_VERSION = 3;\r\n\r\nexport const STORES = {\r\n    replays: \"Replays\",\r\n    lists: \"ReplayLists\",\r\n    meta: \"ReplayMeta\",\r\n    config: \"Config\",\r\n    directoryHandles: \"DirectoryHandles\",\r\n};\r\n\r\nlet db: IDBDatabase | null = null;\r\n\r\nexport function openDB(): Promise<IDBDatabase> {\r\n    return new Promise((resolve, reject) => {\r\n        if (db) {\r\n            resolve(db);\r\n            return;\r\n        }\r\n\r\n        const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n\r\n        request.onupgradeneeded = (event) => {\r\n            const database = (event.target as IDBOpenDBRequest).result;\r\n            const tx = (event.target as IDBOpenDBRequest).transaction!;\r\n            const oldVersion = event.oldVersion;\r\n\r\n            // Apply migrations incrementally\r\n            for (let v = oldVersion; v < DB_VERSION; v++) {\r\n                const migration = upgrades[v];\r\n                if (migration?.schema) {\r\n                    migration.schema(database, tx);\r\n                }\r\n            }\r\n        };\r\n\r\n        request.onsuccess = () => {\r\n            db = request.result;\r\n\r\n            resolve(db);\r\n        };\r\n\r\n        request.onerror = () => reject(request.error);\r\n    });\r\n}\r\n\r\nexport function closeDB(): void {\r\n    if (db) {\r\n        db.close();\r\n        db = null;\r\n    }\r\n}\r\n\r\n\r\nexport function migrateDump(dump: Dump): Dump {\r\n  let version = dump.__meta.dbVersion;\r\n\r\n  while (version < DB_VERSION) {\r\n    const migration = upgrades[version];\r\n\r\n    if (migration?.data) {\r\n      dump = migration.data(dump); // can touch any store\r\n    } else {\r\n      dump.__meta.dbVersion = version + 1;\r\n    }\r\n\r\n    version = dump.__meta.dbVersion;\r\n  }\r\n\r\n  return dump;\r\n}\r\n\r\n\r\nexport const migration0: Migration = {\r\n    schema: (db, tx) => {\r\n        const replayStore = db.objectStoreNames.contains(STORES.replays)\r\n            ? tx.objectStore(STORES.replays)\r\n            : db.createObjectStore(STORES.replays, { keyPath: \"replayHash\" });\r\n\r\n        if (!replayStore.indexNames.contains(\"gametime\")) {\r\n            replayStore.createIndex(\"gametime\", \"gametime\", { unique: false });\r\n        }\r\n\r\n        const listsStore = db.objectStoreNames.contains(STORES.lists)\r\n            ? tx.objectStore(STORES.lists)\r\n            : db.createObjectStore(STORES.lists, { keyPath: \"replayHash\" });\r\n\r\n        if (!listsStore.indexNames.contains(\"gametime\")) {\r\n            listsStore.createIndex(\"gametime\", \"gametime\", { unique: false });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"gameMode\")) {\r\n            listsStore.createIndex(\"gameMode\", \"gameMode\", { unique: false });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"playerNames\")) {\r\n            listsStore.createIndex(\"playerNames\", \"playerNames\", { multiEntry: true });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"commandersTeam1\")) {\r\n            listsStore.createIndex(\"commandersTeam1\", \"commandersTeam1\", { multiEntry: true });\r\n        }\r\n        if (!listsStore.indexNames.contains(\"commandersTeam2\")) {\r\n            listsStore.createIndex(\"commandersTeam2\", \"commandersTeam2\", { multiEntry: true });\r\n        }\r\n\r\n        if (!db.objectStoreNames.contains(STORES.meta)) {\r\n            const store = db.createObjectStore(STORES.meta, { keyPath: \"replayHash\" });\r\n            store.createIndex(\"uploaded\", \"uploaded\", { unique: false });\r\n            store.createIndex(\"filePath\", \"filePath\", { unique: false });\r\n            store.createIndex(\"skip\", \"skip\", { unique: false });\r\n        }\r\n\r\n        if (!db.objectStoreNames.contains(STORES.config)) {\r\n            db.createObjectStore(STORES.config);\r\n        }\r\n    },\r\n};\r\n\r\nconst migration1: Migration = {\r\n  data: (dump) => {\r\n    // Adjust ReplayMeta\r\n    const meta = dump.stores[STORES.meta] as any[] | undefined;\r\n    if (meta) {\r\n      for (const record of meta) {\r\n        if (typeof record.uploaded === \"boolean\") {\r\n          record.uploaded = record.uploaded ? 1 : 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Example: adjust ReplayLists\r\n    const lists = dump.stores[STORES.lists] as any[] | undefined;\r\n    if (lists) {\r\n      for (const list of lists) {\r\n        if (!list.playerNames) list.playerNames = [];\r\n      }\r\n    }\r\n\r\n    dump.__meta.dbVersion = 2;\r\n    return dump;\r\n  },\r\n};\r\n\r\nconst migration2: Migration = {\r\n  schema: (db, tx) => {\r\n    if (!db.objectStoreNames.contains(STORES.directoryHandles)) {\r\n      // no keyPath: we'll use arbitrary string keys (e.g. 'replayDir')\r\n      db.createObjectStore(STORES.directoryHandles);\r\n    }\r\n  },\r\n};\r\n\r\n\r\nconst upgrades: Record<number, Migration> = {\r\n  0: migration0, // initial schema\r\n  1: migration1, // uploaded boolean â†’ number, can modify other stores too\r\n  2: migration2, // new store for directory handles\r\n};","// dsstatsDb.ts v1.4\r\nimport { openDB, STORES } from \"./db-core\";\r\nimport { ExportedReplays, FileInfoRecord, PlayerDto, PwaConfig, ReplayDto, ReplayFilter, ReplayListDto, ReplayMeta, UploadRequestDto, ExportResult } from \"./dtos\";\r\nimport { getReplaysFromFolder, readFileContentStream } from \"./pick-replays\";\r\nimport { exportBackup, importBackup } from \"./backup\";\r\nimport { MyPlayerStats } from \"./stats/stats-dto\";\r\nimport { StatsService } from \"./stats/stats\";\r\nimport { deleteDirectoryHandle, getAllDirectoryHandles, getDirectoryHandle } from \"./file-handle-repository\";\r\n\r\n// Save replay and its projection + meta in one transaction\r\nexport async function saveReplayFull(\r\n    replayHash: string,\r\n    replay: ReplayDto,\r\n    list: ReplayListDto,\r\n    meta: ReplayMeta\r\n): Promise<void> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const tx = database.transaction([STORES.replays, STORES.lists, STORES.meta], \"readwrite\");\r\n\r\n        const replays = tx.objectStore(STORES.replays);\r\n        const lists = tx.objectStore(STORES.lists);\r\n        const metas = tx.objectStore(STORES.meta);\r\n\r\n        replays.put({ ...replay, replayHash: replayHash, gametime: replay.gametime });\r\n        lists.put({ ...list, gametime: list.gametime });\r\n        metas.put(meta);\r\n\r\n        tx.oncomplete = () => resolve();\r\n        tx.onerror = () => reject(tx.error);\r\n    });\r\n}\r\n\r\n// Query for overview table\r\nexport async function getAllReplayLists(): Promise<ReplayListDto[]> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const tx = database.transaction(STORES.lists, \"readonly\");\r\n        const store = tx.objectStore(STORES.lists);\r\n\r\n        const request = store.getAll();\r\n\r\n        request.onsuccess = () => {\r\n            const results = request.result.map((r: ReplayListDto) => ({\r\n                ...r,\r\n                gameTime: r.gametime,\r\n            }));\r\n            resolve(results);\r\n        };\r\n\r\n        request.onerror = () => reject(request.error);\r\n    });\r\n}\r\n\r\nexport async function getAllReplayMatas(): Promise<ReplayMeta[]> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const tx = database.transaction(STORES.meta, \"readonly\");\r\n        const store = tx.objectStore(STORES.meta);\r\n\r\n        const request = store.getAll();\r\n\r\n        request.onsuccess = () => {\r\n            resolve(request.result);\r\n        };\r\n\r\n        request.onerror = () => reject(request.error);\r\n    });\r\n}\r\n\r\n/**\r\n * Get a full ReplayDto by replayHash\r\n */\r\nexport async function getReplayByHash(hash: string): Promise<ReplayDto | undefined> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const tx = database.transaction(STORES.replays, \"readonly\");\r\n        const store = tx.objectStore(STORES.replays);\r\n\r\n        const request = store.get(hash);\r\n\r\n        request.onsuccess = () => {\r\n            const result = request.result as ReplayDto | undefined;\r\n            if (result) {\r\n                result.gametime = new Date(result.gametime).toISOString();\r\n            }\r\n            resolve(result);\r\n        };\r\n\r\n        request.onerror = () => reject(request.error);\r\n    });\r\n}\r\n\r\n/**\r\n * Get the latest N unuploaded replays and return their hashes + gzipped data.\r\n */\r\nexport async function exportUnuploadedReplays(limit: number = 1000): Promise<ExportedReplays> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const metaTx = database.transaction(STORES.meta, \"readonly\");\r\n        const metaStore = metaTx.objectStore(STORES.meta);\r\n        const uploadedIndex = metaStore.index(\"uploaded\");\r\n\r\n        // Query all with uploaded == false\r\n        const req = uploadedIndex.getAll(IDBKeyRange.only(0));\r\n\r\n        req.onsuccess = async () => {\r\n            const metas = req.result as { replayHash: string }[];\r\n\r\n            if (metas.length === 0) {\r\n                resolve({ hashes: [], payload: gzipString(\"[]\") });\r\n                return;\r\n            }\r\n\r\n            // Fetch full replays\r\n            const replayTx = database.transaction(STORES.replays, \"readonly\");\r\n            const replayStore = replayTx.objectStore(STORES.replays);\r\n\r\n            const replayPromises = metas.map(\r\n                (m) =>\r\n                    new Promise<{ hash: string; replay?: ReplayDto }>((res, rej) => {\r\n                        const r = replayStore.get(m.replayHash);\r\n                        r.onsuccess = () => res({ hash: m.replayHash, replay: r.result as ReplayDto | undefined });\r\n                        r.onerror = () => rej(r.error);\r\n                    })\r\n            );\r\n\r\n            try {\r\n                const all = await Promise.all(replayPromises);\r\n\r\n                // Filter out undefined\r\n                const valid = all.filter((x) => !!x.replay) as { hash: string; replay: ReplayDto }[];\r\n\r\n                // Sort by gametime desc\r\n                valid.sort(\r\n                    (a, b) =>\r\n                        new Date(b.replay.gametime).getTime() -\r\n                        new Date(a.replay.gametime).getTime()\r\n                );\r\n\r\n                // Limit\r\n                const selected = valid.slice(0, limit);\r\n\r\n                // Collect\r\n                const hashes = selected.map((x) => x.hash);\r\n                const replays = selected.map((x) => x.replay);\r\n\r\n                // Compress\r\n                const payload = gzipString(JSON.stringify(replays));\r\n\r\n                resolve({ hashes, payload });\r\n            } catch (err) {\r\n                reject(err);\r\n            }\r\n        };\r\n\r\n        req.onerror = () => reject(req.error);\r\n    });\r\n}\r\n\r\n/**\r\n * Get the latest N unuploaded replays and return their hashes + gzipped data.\r\n */\r\nexport async function exportUnuploadedReplays10(uploadRequest: UploadRequestDto, limit: number = 250): Promise<ExportResult> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const metaTx = database.transaction(STORES.meta, \"readonly\");\r\n        const metaStore = metaTx.objectStore(STORES.meta);\r\n        const uploadedIndex = metaStore.index(\"uploaded\");\r\n\r\n        // Query all with uploaded == false\r\n        const req = uploadedIndex.getAll(IDBKeyRange.only(0));\r\n\r\n        req.onsuccess = async () => {\r\n            const metas = req.result as { replayHash: string }[];\r\n\r\n            if (metas.length === 0) {\r\n                resolve({ hashes: [], payload: new Uint8Array() });\r\n                return;\r\n            }\r\n\r\n            // Fetch full replays\r\n            const replayTx = database.transaction(STORES.replays, \"readonly\");\r\n            const replayStore = replayTx.objectStore(STORES.replays);\r\n\r\n            const replayPromises = metas.map(\r\n                (m) =>\r\n                    new Promise<{ hash: string; replay?: ReplayDto }>((res, rej) => {\r\n                        const r = replayStore.get(m.replayHash);\r\n                        r.onsuccess = () => res({ hash: m.replayHash, replay: r.result as ReplayDto | undefined });\r\n                        r.onerror = () => rej(r.error);\r\n                    })\r\n            );\r\n\r\n            try {\r\n                const all = await Promise.all(replayPromises);\r\n\r\n                // Filter out undefined\r\n                const valid = all.filter((x) => !!x.replay) as { hash: string; replay: ReplayDto }[];\r\n\r\n                // Sort by gametime desc\r\n                valid.sort(\r\n                    (a, b) =>\r\n                        new Date(b.replay.gametime).getTime() -\r\n                        new Date(a.replay.gametime).getTime()\r\n                );\r\n\r\n                // Limit\r\n                const selected = valid.slice(0, limit);\r\n\r\n                // Collect\r\n                const hashes = selected.map((x) => x.hash);\r\n                const replays = selected.map((x) => x.replay);\r\n\r\n                // Create a plain JS object from the .NET proxy object to avoid stack overflow issues\r\n                // when stringifying an object that contains a .NET proxy.\r\n                const plainUploadRequest = JSON.parse(JSON.stringify(uploadRequest));\r\n\r\n                const request: UploadRequestDto = {\r\n                    ...plainUploadRequest,\r\n                    replays\r\n                };\r\n\r\n                // Compress\r\n                const payload = gzipStringRaw(JSON.stringify(request));\r\n\r\n                resolve({ hashes, payload });\r\n            } catch (err) {\r\n                console.error(\"exportUnuploadedReplays10 failed:\", err);\r\n                reject(err);\r\n            }\r\n        };\r\n\r\n        req.onerror = () => reject(req.error);\r\n    });\r\n}\r\n\r\nexport async function markReplaysAsUploaded(hashes: string[]): Promise<void> {\r\n    const database = await openDB();\r\n    const tx = database.transaction(STORES.meta, \"readwrite\");\r\n    const store = tx.objectStore(STORES.meta);\r\n\r\n    await Promise.all(\r\n        hashes.map(\r\n            (hash) =>\r\n                new Promise<void>((res, rej) => {\r\n                    const getReq = store.get(hash);\r\n                    getReq.onsuccess = () => {\r\n                        const record = getReq.result;\r\n                        if (record) {\r\n                            record.uploaded = 1;\r\n                            const putReq = store.put(record);\r\n                            putReq.onsuccess = () => res();\r\n                            putReq.onerror = () => rej(putReq.error);\r\n                        } else {\r\n                            res(); // nothing to update\r\n                        }\r\n                    };\r\n                    getReq.onerror = () => rej(getReq.error);\r\n                })\r\n        )\r\n    );\r\n}\r\n\r\nexport async function pickDirectoryInit(\r\n    regionId: number,\r\n    startName: string,\r\n    dirKey?: string,\r\n    count: number = 100\r\n): Promise<FileInfoRecord[]> {\r\n    const metas = await getAllReplayMatas();\r\n    const paths = metas.filter(f => f.regionId === regionId).map(m => m.filePath);\r\n    const dirHandle = !dirKey ? null : await getDirectoryHandle(dirKey);\r\n    return await getReplaysFromFolder(regionId, startName, paths, count, dirHandle ?? undefined);\r\n}\r\n\r\nexport async function getFileContentStream(path: string) {\r\n    return await readFileContentStream(path);\r\n}\r\n\r\nexport async function getConfig(): Promise<PwaConfig | undefined> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const tx = database.transaction(STORES.config, \"readonly\");\r\n        const store = tx.objectStore(STORES.config);\r\n\r\n        const request = store.get(\"app\");\r\n\r\n        request.onsuccess = () => {\r\n            resolve(request.result);\r\n        };\r\n\r\n        request.onerror = () => reject(request.error);\r\n    });\r\n}\r\n\r\nexport async function saveConfig(\r\n    config: PwaConfig,\r\n): Promise<void> {\r\n    const database = await openDB();\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const tx = database.transaction(STORES.config, \"readwrite\");\r\n\r\n        const configs = tx.objectStore(STORES.config);\r\n        configs.put(config, \"app\");\r\n\r\n        tx.oncomplete = () => resolve();\r\n        tx.onerror = () => reject(tx.error);\r\n    });\r\n}\r\n\r\n\r\n\r\nasync function _getFilteredReplayLists(filter: ReplayFilter): Promise<ReplayListDto[]> {\r\n    const database = await openDB();\r\n\r\n    const hasNameFilter = filter.name && filter.name.length > 0;\r\n    const hasCommandersFilter = filter.commanders && filter.commanders.length > 0;\r\n\r\n    const tx = database.transaction(STORES.lists, \"readonly\");\r\n    const store = tx.objectStore(STORES.lists);\r\n\r\n    let initialReplayLists: ReplayListDto[] = [];\r\n\r\n    if (hasCommandersFilter) {\r\n        const team1Index = store.index(\"commandersTeam1\");\r\n        const team2Index = store.index(\"commandersTeam2\");\r\n        const addedHashes = new Set<string>();\r\n\r\n        const promises = filter.commanders!.map(commander => {\r\n            return [\r\n                new Promise<ReplayListDto[]>((res, rej) => {\r\n                    const req = team1Index.getAll(IDBKeyRange.only(commander));\r\n                    req.onsuccess = () => res(req.result);\r\n                    req.onerror = () => rej(req.error);\r\n                }),\r\n                new Promise<ReplayListDto[]>((res, rej) => {\r\n                    const req = team2Index.getAll(IDBKeyRange.only(commander));\r\n                    req.onsuccess = () => res(req.result);\r\n                    req.onerror = () => rej(req.error);\r\n                })\r\n            ];\r\n        }).flat();\r\n\r\n        const results = await Promise.all(promises);\r\n        results.flat().forEach(replay => {\r\n            if (!addedHashes.has(replay.replayHash)) {\r\n                initialReplayLists.push(replay);\r\n                addedHashes.add(replay.replayHash);\r\n            }\r\n        });\r\n    } else {\r\n        initialReplayLists = await new Promise<ReplayListDto[]>((res, rej) => {\r\n            const req = store.getAll();\r\n            req.onsuccess = () => res(req.result);\r\n            req.onerror = () => rej(req.error);\r\n        });\r\n    }\r\n\r\n    if (!hasNameFilter) {\r\n        return initialReplayLists;\r\n    }\r\n\r\n    const searchNames = hasNameFilter ? filter.name!.toLowerCase().split(' ').filter(n => n) : [];\r\n\r\n    return initialReplayLists.filter(replayList => {\r\n        if (filter.linkCommanders && hasNameFilter && hasCommandersFilter) {\r\n            const lowerCasePlayerNames = replayList.playerNames.map(name => name.toLowerCase());\r\n            const allCommanders = [...replayList.commandersTeam1, ...replayList.commandersTeam2];\r\n\r\n            return lowerCasePlayerNames.some((playerName, playerIndex) => {\r\n                const nameMatch = searchNames.every(searchName => playerName.includes(searchName));\r\n                if (nameMatch) {\r\n                    const commander = allCommanders[playerIndex];\r\n                    return filter.commanders!.includes(commander);\r\n                }\r\n                return false;\r\n            });\r\n        }\r\n\r\n        if (hasNameFilter) {\r\n            const lowerCasePlayerNames = replayList.playerNames.map(name => name.toLowerCase());\r\n            return searchNames.every(searchName => lowerCasePlayerNames.some(playerName => playerName.includes(searchName)));\r\n        }\r\n\r\n        return true;\r\n    });\r\n}\r\n\r\nexport async function getFilteredReplayLists(\r\n    filter: ReplayFilter\r\n): Promise<ReplayListDto[]> {\r\n    const filteredResults = await _getFilteredReplayLists(filter);\r\n\r\n    const orders = (filter.tableOrders && filter.tableOrders.length > 0)\r\n        ? filter.tableOrders\r\n        : [{ name: 'gametime', ascending: false }];\r\n\r\n    filteredResults.sort((a, b) => {\r\n        for (const order of orders) {\r\n            const aValue = a[order.name as keyof ReplayListDto];\r\n            const bValue = b[order.name as keyof ReplayListDto];\r\n\r\n            // Assuming array properties are not used for sorting\r\n            if (Array.isArray(aValue) || Array.isArray(bValue)) {\r\n                continue;\r\n            }\r\n\r\n            const valA = aValue === undefined ? 0 : aValue;\r\n            const valB = bValue === undefined ? 0 : bValue;\r\n\r\n            if (valA < valB) {\r\n                return order.ascending ? -1 : 1;\r\n            }\r\n            if (valA > valB) {\r\n                return order.ascending ? 1 : -1;\r\n            }\r\n        }\r\n        return 0;\r\n    });\r\n\r\n    if (filter.skip !== undefined && filter.take !== undefined) {\r\n        return filteredResults.slice(filter.skip, filter.skip + filter.take);\r\n    }\r\n    return filteredResults;\r\n}\r\n\r\nexport async function getFilteredReplayListsCount(filter: ReplayFilter): Promise<number> {\r\n    const filteredResults = await _getFilteredReplayLists(filter);\r\n    return filteredResults.length;\r\n}\r\n\r\nexport async function downloadBackup() {\r\n    await exportBackup();\r\n}\r\n\r\nexport async function uploadBackup() {\r\n    await importBackup();\r\n}\r\n\r\nexport function gzipString(content: string): string {\r\n    const binary = pako.gzip(content);\r\n    return btoa(String.fromCharCode(...binary));\r\n}\r\n\r\nexport function gzipStringRaw(content: string): Uint8Array {\r\n    return pako.gzip(content);\r\n}\r\n\r\nexport function ungzipString(base64: string): string {\r\n    const binary = Uint8Array.from(atob(base64), c => c.charCodeAt(0));\r\n    const text = pako.ungzip(binary, { to: \"string\" });\r\n    return text;\r\n}\r\n\r\nexport async function getPlayerStats(player: PlayerDto): Promise<MyPlayerStats> {\r\n    const statsService = new StatsService();\r\n    return await statsService.generateStats(player);\r\n}\r\n\r\nexport async function exportAllDirectoryHandles(): Promise<string[]> {\r\n    return await getAllDirectoryHandles();\r\n}\r\n\r\nexport async function delDirectoryHandle(key: string): Promise<void> {\r\n    await deleteDirectoryHandle(key);\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(82);\n"],"names":["Map","toonKey","toon","region","realm","id","StatsService","generateStats","player","gameModeMap","afterKey","replays","lastKey","this","getReplayChunk","length","replay","has","gameMode","set","commanderStats","teammateStats","opponentStats","gameModeStats","get","setStats","stats","builder","entries","push","Array","from","values","filter","s","count","recentReplays","name","skip","take","myReplayPlayer","players","find","f","toonId","team","teamId","win","winnerTeam","commander","race","isMvp","wins","mvp","replayPlayer","key","playerStatsMap","playerStats","replayPlayers","kills","spawns","breakpoint","killedValue","maxKills","rp","findMainPlayer","allReplays","getReplayChunkFromStart","playerCounts","size","mainPlayer","playerStat","db","Promise","resolve","reject","index","transaction","objectStore","request","openCursor","onsuccess","event","cursor","target","result","value","continue","onerror","error","range","IDBKeyRange","upperBound","STORES","lists","meta","config","directoryHandles","openDB","indexedDB","open","onupgradeneeded","database","tx","v","oldVersion","migration","upgrades","schema","migration0","replayStore","objectStoreNames","contains","createObjectStore","keyPath","indexNames","createIndex","unique","listsStore","multiEntry","store","migration2","data","dump","stores","record","uploaded","list","playerNames","__meta","dbVersion","async","_getFilteredReplayLists","hasNameFilter","hasCommandersFilter","commanders","initialReplayLists","team1Index","team2Index","addedHashes","Set","promises","map","res","rej","req","getAll","only","flat","all","forEach","replayHash","add","searchNames","toLowerCase","split","n","replayList","linkCommanders","lowerCasePlayerNames","allCommanders","commandersTeam1","commandersTeam2","some","playerName","playerIndex","every","searchName","includes","getFilteredReplayLists","filteredResults","orders","tableOrders","ascending","sort","a","b","order","aValue","bValue","isArray","valA","undefined","valB","slice","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","d","definition","o","Object","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call"],"ignoreList":[],"sourceRoot":""}